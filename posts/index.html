<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Data Science with R">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Data Science with R</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://r.datascience.eu.org/posts/">
<link rel="icon" href="../files/favicon.ico" sizes="16x16">
<link rel="next" href="index-3.html" type="text/html">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="https://r.datascience.eu.org/">

            <span id="blog-title">Data Science with R</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../toc/" class="nav-link">Table of Contents</a>
                </li>
<li class="nav-item">
<a href="../categories/" class="nav-link">Categories</a>
                </li>
<li class="nav-item">
<a href="../tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="https://www.datascience.eu.org" class="nav-link">Main site</a>

                
            </li>
</ul>
<!-- DuckDuckGo custom search --><form method="get" id="search" action="https://duckduckgo.com/" class="navbar-form pull-left">
<input type="hidden" name="sites" value="https://r.datascience.eu.org/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="visibility: hidden;">
</form>
<!-- End of custom search -->


            <ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00430/" class="u-url">K Means Clustering</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00430/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-09T20:57:54+05:30" itemprop="datePublished" title="2020-05-09 20:57">2020-05-09 20:57</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00430/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00430_K Means Clustering.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00430_K Means Clustering.html";
var idcomments_post_url = "/posts/00430/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote>
<p>library(swirl)<br>
swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>

<pre><code> 1: Principles of Analytic Graphs   2: Exploratory Graphs             
 3: Graphics Devices in R           4: Plotting Systems               
 5: Base Plotting System            6: Lattice Plotting System        
 7: Working with Colors             8: GGPlot2 Part1                  
 9: GGPlot2 Part2                  10: GGPlot2 Extras                 
11: Hierarchical Clustering        12: K Means Clustering             
13: Dimension Reduction            14: Clustering Example             
15: CaseStudy</code></pre>
<p>Selection: 12</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>| Package ‘fields’ loaded correctly!</p>
<p>| Package ‘jpeg’ loaded correctly!</p>
<p>| Package ‘datasets’ loaded correctly!</p>
<p>|                                                                             |   0%</p>
<p>| K_Means_Clustering. (Slides for this and other Data Science courses may be found at<br>
| github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use<br>
| them, they must be downloaded as a zip file and viewed locally. This lesson<br>
| corresponds to 04_ExploratoryAnalysis/kmeansClustering.)</p>
<p>...</p>
<p>|==                                                                           |   2%<br>
| In this lesson we'll learn about k-means clustering, another simple way of examining<br>
| and organizing multi-dimensional data. As with hierarchical clustering, this<br>
| technique is most useful in the early stages of analysis when you're trying to get<br>
| an understanding of the data, e.g., finding some pattern or relationship between<br>
| different factors or variables.</p>
<p>...</p>
<p>|===                                                                          |   4%<br>
| R documentation tells us that the k-means method "aims to partition the points into<br>
| k groups such that the sum of squares from points to the assigned cluster centres is<br>
| minimized."</p>
<p>...</p>
<p>|=====                                                                        |   6%<br>
| Since clustering organizes data points that are close into groups we'll assume we've<br>
| decided on a measure of distance, e.g., Euclidean.</p>
<p>...</p>
<p>|======                                                                       |   8%<br>
| To illustrate the method, we'll use these random points we generated, familiar to<br>
| you if you've already gone through the hierarchical clustering lesson. We'll<br>
| demonstrate k-means clustering in several steps, but first we'll explain the general<br>
| idea.</p>
<p><img src="../images/r0041430.png" alt="image" title="image"><br>
...</p>
<p>|========                                                                     |  10%<br>
| As we said, k-means is a partioning approach which requires that you first guess how<br>
| many clusters you have (or want). Once you fix this number, you randomly create a<br>
| "centroid" (a phantom point) for each cluster and assign each point or observation<br>
| in your dataset to the centroid to which it is closest. Once each point is assigned<br>
| a centroid, you readjust the centroid's position by making it the average of the<br>
| points assigned to it.</p>
<p>...</p>
<p>|=========                                                                    |  12%<br>
| Once you have repositioned the centroids, you must recalculate the distance of the<br>
| observations to the centroids and reassign any, if necessary, to the centroid<br>
| closest to them. Again, once the reassignments are done, readjust the positions of<br>
| the centroids based on the new cluster membership. The process stops once you reach<br>
| an iteration in which no adjustments are made or when you've reached some<br>
| predetermined maximum number of iterations.</p>
<p>...</p>
<p>|===========                                                                  |  14%<br>
| As described, what does this process require?</p>
<p>1: All of the others<br>
2: A number of clusters<br>
3: A defined distance metric<br>
4: An initial guess as to cluster centroids</p>
<p>Selection: 1</p>
<p>| That's the answer I was looking for.</p>
<p>|============                                                                 |  16%<br>
| So k-means clustering requires some distance metric (say Euclidean), a hypothesized<br>
| fixed number of clusters, and an initial guess as to cluster centroids. As<br>
| described, what does this process produce?</p>
<p>1: All of the others<br>
2: An assignment of each point to a cluster<br>
3: A final estimate of cluster centroids</p>
<p>Selection: 1</p>
<p>| You nailed it! Good job!</p>
<p>|==============                                                               |  18%<br>
| When it's finished k-means clustering returns a final position of each cluster's<br>
| centroid as well as the assignment of each data point or observation to a cluster.</p>
<p>...</p>
<p>|===============                                                              |  20%<br>
| Now we'll step through this process using our random points as our data. The<br>
| coordinates of these are stored in 2 vectors, x and y. We eyeball the display and<br>
| guess that there are 3 clusters. We'll pick 3 positions of centroids, one for each<br>
| cluster.</p>
<p>...</p>
<p>|=================                                                            |  22%<br>
| We've created two 3-long vectors for you, cx and cy. These respectively hold the x-<br>
| and y- coordinates for 3 proposed centroids. For convenience, we've also stored them<br>
| in a 2 by 3 matrix cmat. The x coordinates are in the first row and the y<br>
| coordinates in the second. Look at cmat now.</p>
<blockquote>
<p>cmat</p>

<pre><code>     [,1] [,2] [,3]  
[1,]    1  1.8  2.5  
[2,]    2  1.0  1.5</code></pre>
<p>| Excellent work!</p>
</blockquote>
<p>|==================                                                           |  24%<br>
| The coordinates of these points are (1,2), (1.8,1) and (2.5,1.5). We'll add these<br>
| centroids to the plot of our points. Do this by calling the R command points with 6<br>
| arguments. The first 2 are cx and cy, and the third is col set equal to the<br>
| concatenation of 3 colors, "red", "orange", and "purple". The fourth argument is pch<br>
| set equal to 3 (a plus sign), the fifth is cex set equal to 2 (expansion of<br>
| character), and the final is lwd (line width) also set equal to 2.</p>
<blockquote>
<p>points(cx,cy,col=c("red","orange","purple"),pch=3,cex=2,lwd=2)</p>
</blockquote>
<p><img src="../images/r0041570.png" alt="image" title="image"></p>
<p>| You nailed it! Good job!</p>
<p>|====================                                                         |  26%<br>
| We see the first centroid (1,2) is in red. The second (1.8,1), to the right and<br>
| below the first, is orange, and the final centroid (2.5,1.5), the furthest to the<br>
| right, is purple.</p>
<p>...</p>
<p>|======================                                                       |  28%<br>
| Now we have to calculate distances between each point and every centroid. There are<br>
| 12 data points and 3 centroids. How many distances do we have to calculate?</p>
<p>1: 15<br>
2: 108<br>
3: 36<br>
4: 9</p>
<p>Selection: 3</p>
<p>| You are amazing!</p>
<p>|=======================                                                      |  30%<br>
| We've written a function for you called mdist which takes 4 arguments. The vectors<br>
| of data points (x and y) are the first two and the two vectors of centroid<br>
| coordinates (cx and cy) are the last two. Call mdist now with these arguments.</p>
<blockquote>
<p>mdist(x,y,cx,cy)</p>

<pre><code>         [,1]      [,2]      [,3]     [,4]      [,5]      [,6]      [,7]     [,8]  
[1,] 1.392885 0.9774614 0.7000680 1.264693 1.1894610 1.2458771 0.8113513 1.026750  
[2,] 1.108644 0.5544675 0.3768445 1.611202 0.8877373 0.7594611 0.7003994 2.208006  
[3,] 3.461873 2.3238956 1.7413021 4.150054 0.3297843 0.2600045 0.4887610 1.337896  
          [,9]     [,10]     [,11]     [,12]  
[1,] 4.5082665 4.5255617 4.8113368 4.0657750  
[2,] 1.1825265 1.0540994 1.2278193 1.0090944  
[3,] 0.3737554 0.4614472 0.5095428 0.2567247</code></pre>
<p>| Excellent job!</p>
</blockquote>
<p>|=========================                                                    |  32%<br>
| We've stored these distances in the matrix distTmp for you. Now we have to assign a<br>
| cluster to each point. To do that we'll look at each column and ?</p>
<p>1: add up the 3 entries.<br>
2: pick the minimum entry<br>
3: pick the maximum entry</p>
<p>Selection: 2</p>
<p>| Perseverance, that's the answer.</p>
<p>|==========================                                                   |  34%<br>
| From the distTmp entries, which cluster would point 6 be assigned to?</p>
<p>1: none of the above<br>
2: 3<br>
3: 2<br>
4: 1</p>
<p>Selection: 2</p>
<p>| Keep working like that and you'll get there!</p>
<p>|============================                                                 |  36%<br>
| R has a handy function which.min which you can apply to ALL the columns of distTmp<br>
| with one call. Simply call the R function apply with 3 arguments. The first is<br>
| distTmp, the second is 2 meaning the columns of distTmp, and the third is which.min,<br>
| the function you want to apply to the columns of distTmp. Try this now.</p>
<blockquote>
<p>apply(distTmp,2,which.min)<br>
 [1] 2 2 2 1 3 3 3 1 3 3 3 3</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|=============================                                                |  38%<br>
| You can see that you were right and the 6th entry is indeed 3 as you answered<br>
| before. We see the first 3 entries were assigned to the second (orange) cluster and<br>
| only 2 points (4 and 8) were assigned to the first (red) cluster.</p>
<p>...</p>
<p>|===============================                                              |  40%<br>
| We've stored the vector of cluster colors ("red","orange","purple") in the array<br>
| cols1 for you and we've also stored the cluster assignments in the array newClust.<br>
| Let's color the 12 data points according to their assignments. Again, use the<br>
| command points with 5 arguments. The first 2 are x and y. The third is pch set to<br>
| 19, the fourth is cex set to 2, and the last, col is set to cols1[newClust].</p>
<blockquote>
<p>points(x,y,pch=19,cex=2,col=cols1[newClust])</p>
</blockquote>
<p><img src="../images/r0041580.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|================================                                             |  42%<br>
| Now we have to recalculate our centroids so they are the average (center of gravity)<br>
| of the cluster of points assigned to them. We have to do the x and y coordinates<br>
| separately. We'll do the x coordinate first. Recall that the vectors x and y hold<br>
| the respective coordinates of our 12 data points.</p>
<p>...</p>
<p>|==================================                                           |  44%<br>
| We can use the R function tapply which applies "a function over a ragged array".<br>
| This means that every element of the array is assigned a factor and the function is<br>
| applied to subsets of the array (identified by the factor vector). This allows us to<br>
| take advantage of the factor vector newClust we calculated. Call tapply now with 3<br>
| arguments, x (the data), newClust (the factor array), and mean (the function to<br>
| apply).</p>
<blockquote>
<p>tapply(x,newClust,mean)</p>

<pre><code>       1        2        3   
1.210767 1.010320 2.498011</code></pre>
<p>| Perseverance, that's the answer.</p>
</blockquote>
<p>|===================================                                          |  46%<br>
| Repeat the call, except now apply it to the vector y instead of x.</p>
<blockquote>
<p>tapply(y,newClust,mean)</p>

<pre><code>       1        2        3   
1.730555 1.016513 1.354373</code></pre>
<p>| Your dedication is inspiring!</p>
</blockquote>
<p>|=====================================                                        |  48%<br>
| Now that we have new x and new y coordinates for the 3 centroids we can plot them.<br>
| We've stored off the coordinates for you in variables newCx and newCy. Use the R<br>
| command points with these as the first 2 arguments. In addition, use the arguments<br>
| col set equal to cols1, pch equal to 8, cex equal to 2 and lwd also equal to 2.</p>
<blockquote>
<p>points(newCx,newCy,col=cols1,pch=8,cex=2,lwd=2)</p>
</blockquote>
<p><img src="../images/r0041590.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|======================================                                       |  50%<br>
| We see how the centroids have moved closer to their respective clusters. This is<br>
| especially true of the second (orange) cluster. Now call the distance function mdist<br>
| with the 4 arguments x, y, newCx, and newCy. This will allow us to reassign the data<br>
| points to new clusters if necessary.</p>
<blockquote>
<p>mdist(x,y,newCx,newCy)</p>

<pre><code>           [,1]        [,2]      [,3]      [,4]      [,5]      [,6]      [,7]     [,8]  
[1,] 0.98911875 0.539152725 0.2901879 1.0286979 0.7936966 0.8004956 0.4650664 1.028698  
[2,] 0.09287262 0.002053041 0.0734304 0.2313694 1.9333732 1.8320407 1.4310971 2.926095  
[3,] 3.28531180 2.197487387 1.6676725 4.0113796 0.4652075 0.3721778 0.6043861 1.643033  
          [,9]    [,10]     [,11]     [,12]  
[1,] 3.3053706 3.282778 3.5391512 2.9345445  
[2,] 3.5224442 3.295301 3.5990955 3.2097944  
[3,] 0.2586908 0.309730 0.3610747 0.1602755</code></pre>
<p>| Excellent work!</p>
</blockquote>
<p>|========================================                                     |  52%<br>
| We've stored off this new matrix of distances in the matrix distTmp2 for you. Recall<br>
| that the first cluster is red, the second orange and the third purple. Look closely<br>
| at columns 4 and 7 of distTmp2. What will happen to points 4 and 7?</p>
<p>1: They will both change to cluster 2<br>
2: Nothing<br>
3: They're the only points that won't change clusters<br>
4: They will both change clusters</p>
<p>Selection: 4</p>
<p>| You nailed it! Good job!</p>
<p>|==========================================                                   |  54%<br>
| Now call apply with 3 arguments, distTmp2, 2, and which.min to find the new cluster<br>
| assignments for the points.</p>
<blockquote>
<p>apply(distTmp2,2,which.min)<br>
 [1] 2 2 2 2 3 3 1 1 3 3 3 3</p>
</blockquote>
<p>| That's a job well done!</p>
<p>|===========================================                                  |  56%<br>
| We've stored off the new cluster assignments in a vector of factors called<br>
| newClust2. Use the R function points to recolor the points with their new<br>
| assignments. Again, there are 5 arguments, x and y are first, followed by pch set to<br>
| 19, cex to 2, and col to cols1[newClust2].</p>
<blockquote>
<p>points(x,y,pch=19,cex=2,col=cols1[newClust2])</p>
</blockquote>
<p><img src="../images/r0041600.png" alt="image" title="image"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|=============================================                                |  58%<br>
| Notice that points 4 and 7 both changed clusters, 4 moved from 1 to 2 (red to<br>
| orange), and point 7 switched from 3 to 2 (purple to red).</p>
<p>...</p>
<p>|==============================================                               |  60%<br>
| Now use tapply to find the x coordinate of the new centroid. Recall there are 3<br>
| arguments, x, newClust2, and mean.</p>
<blockquote>
<p>tapply(x,newClust2,mean)</p>

<pre><code>        1         2         3   
1.8878628 0.8904553 2.6001704</code></pre>
<p>| You're the best!</p>
</blockquote>
<p>|================================================                             |  62%<br>
| Do the same to find the new y coordinate.</p>
<blockquote>
<p>tapply(y,newClust2,mean)</p>

<pre><code>       1        2        3   
2.157866 1.006871 1.274675</code></pre>
<p>| Excellent work!</p>
</blockquote>
<p>|=================================================                            |  64%<br>
| We've stored off these coordinates for you in the variables finalCx and finalCy.<br>
| Plot these new centroids using the points function with 6 arguments. The first 2 are<br>
| finalCx and finalCy. The argument col should equal cols1, pch should equal 9, cex 2<br>
| and lwd 2.</p>
<blockquote>
<p>points(finalCx,finalCy,col=cols1,pch=9,cex=2,lwd=2)</p>
</blockquote>
<p><img src="../images/r0041610.png" alt="image" title="image"></p>
<p>| You nailed it! Good job!</p>
<p>|===================================================                          |  66%<br>
| It should be obvious that if we continued this process points 5 through 8 would all<br>
| turn red, while points 1 through 4 stay orange, and points 9 through 12 purple.</p>
<p>...</p>
<p>|====================================================                         |  68%<br>
| Now that you've gone through an example step by step, you'll be relieved to hear<br>
| that R provides a command to do all this work for you. Unsurprisingly it's called<br>
| kmeans and, although it has several parameters, we'll just mention four. These are<br>
| x, (the numeric matrix of data), centers, iter.max, and nstart. The second of these<br>
| (centers) can be either a number of clusters or a set of initial centroids. The<br>
| third, iter.max, specifies the maximum number of iterations to go through, and<br>
| nstart is the number of random starts you want to try if you specify centers as a<br>
| number.</p>
<p>...</p>
<p>|======================================================                       |  70%<br>
| Call kmeans now with 2 arguments, dataFrame (which holds the x and y coordinates of<br>
| our 12 points) and centers set equal to 3.</p>
<blockquote>
<p>kmeans(dataFrame,centers=3)<br>
```
K-means clustering with 3 clusters of sizes 4, 4, 4</p>
</blockquote>
<p>Cluster means:</p>

<pre><code>      x         y  
</code></pre>
<p>1 0.8904553 1.0068707<br>
2 2.8534966 0.9831222<br>
3 1.9906904 2.0078229</p>
<p>Clustering vector:<br>
 [1] 1 1 1 1 3 3 3 3 2 2 2 2</p>
<p>Within cluster sum of squares by cluster:<br>
[1] 0.34188313 0.03298027 0.34732441<br>
 (between_SS / total_SS =  93.6 %)</p>
<p>Available components:</p>
<p>[1] "cluster"      "centers"      "totss"        "withinss"     "tot.withinss"<br>
[6] "betweenss"    "size"         "iter"         "ifault"<br>
```<br>
| You are really on a roll!</p>
<p>|=======================================================                      |  72%<br>
| The program returns the information that the data clustered into 3 clusters each of<br>
| size 4. It also returns the coordinates of the 3 cluster means, a vector named<br>
| cluster indicating how the 12 points were partitioned into the clusters, and the sum<br>
| of squares within each cluster. It also shows all the available components returned<br>
| by the function. We've stored off this data for you in a kmeans object called kmObj.<br>
| Look at kmObj$iter to see how many iterations the algorithm went through.</p>
<blockquote>
<p>kmObj$iter<br>
[1] 1</p>
</blockquote>
<p>| You got it!</p>
<p>|=========================================================                    |  74%<br>
| Two iterations as we did before. We just want to emphasize how you can access the<br>
| information available to you. Let's plot the data points color coded according to<br>
| their cluster. This was stored in kmObj$cluster. Run plot with 5 arguments. The  
| data, x and y, are the first two; the third, col is set equal to kmObj$cluster, and<br>
| the last two are pch and cex. The first of these should be set to 19 and the last to<br>
| 2.</p>
<blockquote>
<p>plot(x,y,col=kmObj$cluster,pch=19,cex=2)</p>
</blockquote>
<p><img src="../images/r0041620.png" alt="image" title="image"></p>
<p>| You are doing so well!</p>
<p>|===========================================================                  |  76%<br>
| Now add the centroids which are stored in kmObj$centers. Use the points function  
| with 5 arguments. The first two are kmObj$centers and col=c("black","red","green").<br>
| The last three, pch, cex, and lwd, should all equal 3.</p>
<blockquote>
<p>points(kmObj$centers,col=c("black","red","green"),pch=3,cex=3,lwd=3)</p>
</blockquote>
<p><img src="../images/r0041630.png" alt="image" title="image"></p>
<p>| Excellent work!</p>
<p>|============================================================                 |  78%<br>
| Now for some fun! We want to show you how the output of the kmeans function is<br>
| affected by its random start (when you just ask for a number of clusters). With<br>
| random starts you might want to run the function several times to get an idea of the<br>
| relationships between your observations. We'll call kmeans with the same data points<br>
| (stored in dataFrame), but ask for 6 clusters instead of 3.</p>
<p>...</p>
<p>|==============================================================               |  80%<br>
| We'll plot our data points several times and each time we'll just change the<br>
| argument col which will show us how the R function kmeans is clustering them. So,<br>
| call plot now with 5 arguments. The first 2 are x and y. The third is col set equal<br>
| to the call kmeans(dataFrame,6)$cluster. The last two (pch and cex) are set to 19<br>
| and 2 respectively.</p>
<blockquote>
<p>plot(x,y,col=kmeans(dataFrame,6)$cluster,pch=19,cex=2)</p>
</blockquote>
<p><img src="../images/r0041640.png" alt="image" title="image"></p>
<p>| You nailed it! Good job!</p>
<p>|===============================================================              |  82%<br>
| See how the points cluster? Now recall your last command and rerun it.</p>
<blockquote>
<p>plot(x,y,col=kmeans(dataFrame,6)$cluster,pch=19,cex=2)</p>
</blockquote>
<p><img src="../images/r0041650.png" alt="image" title="image"></p>
<p>| Nice work!</p>
<p>|=================================================================            |  84%<br>
| See how the clustering has changed? As the Teletubbies would say, "Again! Again!"</p>
<blockquote>
<p>plot(x,y,col=kmeans(dataFrame,6)$cluster,pch=19,cex=2)</p>
</blockquote>
<p><img src="../images/r0041660.png" alt="image" title="image"></p>
<p>| That's the answer I was looking for.</p>
<p>|==================================================================           |  86%<br>
| So the clustering changes with different starts. Perhaps 6 is too many clusters?<br>
| Let's review!</p>
<p>...</p>
<p>|====================================================================         |  88%<br>
| True or False? K-means clustering requires you to specify a number of clusters<br>
| before you begin.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| You nailed it! Good job!</p>
<p>|=====================================================================        |  90%<br>
| True or False? K-means clustering requires you to specify a number of iterations<br>
| before you begin.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| You got it right!</p>
<p>|=======================================================================      |  92%<br>
| True or False? Every data set has a single fixed number of clusters.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| Excellent job!</p>
<p>|========================================================================     |  94%<br>
| True or False? K-means clustering will always stop in 3 iterations</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| You are really on a roll!</p>
<p>|==========================================================================   |  96%<br>
| True or False? When starting kmeans with random centroids, you'll always end up with<br>
| the same final clustering.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| Great job!</p>
<p>|===========================================================================  |  98%<br>
| Congratulations! We hope this means you found this lesson oK.</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: No<br>
2: Yes</p>
<p>Selection: 2<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| Excellent work!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-09 20:59:57.636628 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00429/" class="u-url">Hierarchical Clustering</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00429/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-09T20:01:06+05:30" itemprop="datePublished" title="2020-05-09 20:01">2020-05-09 20:01</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00429/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00429_Hierarchical Clustering.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00429_Hierarchical Clustering.html";
var idcomments_post_url = "/posts/00429/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 4.0.0 (2020-04-24) -- "Arbor Day"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>Natural language support but running in an English locale</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<blockquote>
<p>setwd("C:/images")<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>

<pre><code> 1: Principles of Analytic Graphs   2: Exploratory Graphs             
 3: Graphics Devices in R           4: Plotting Systems               
 5: Base Plotting System            6: Lattice Plotting System        
 7: Working with Colors             8: GGPlot2 Part1                  
 9: GGPlot2 Part2                  10: GGPlot2 Extras                 
11: Hierarchical Clustering        12: K Means Clustering             
13: Dimension Reduction            14: Clustering Example             
15: CaseStudy</code></pre>
<p>Selection: 11</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>| This lesson requires the ‘fields’ package. Would you like me to install it for you<br>
| now?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1</p>
<p>| Trying to install package ‘fields’ now...<br>
WARNING: Rtools is required to build R packages but is not currently installed. Please download and install the appropriate version of Rtools before proceeding:</p>
<p><a href="https://cran.rstudio.com/bin/windows/Rtools/">https://cran.rstudio.com/bin/windows/Rtools/</a><br>
also installing the dependencies ‘dotCall64’, ‘spam’, ‘maps’</p>
<p>package ‘dotCall64’ successfully unpacked and MD5 sums checked<br>
package ‘spam’ successfully unpacked and MD5 sums checked<br>
package ‘maps’ successfully unpacked and MD5 sums checked<br>
package ‘fields’ successfully unpacked and MD5 sums checked</p>
<p>| Package ‘fields’ loaded correctly!</p>
<p>| Package ‘jpeg’ loaded correctly!</p>
<p>| Package ‘datasets’ loaded correctly!</p>
<p>|                                                                             |   0%</p>
<p>| Hierarchical_Clustering. (Slides for this and other Data Science courses may be<br>
| found at github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care<br>
| to use them, they must be downloaded as a zip file and viewed locally. This lesson<br>
| corresponds to 04_ExploratoryAnalysis/hierarchicalClustering.)</p>
<p>...</p>
<p>|=                                                                            |   2%<br>
| In this lesson we'll learn about hierarchical clustering, a simple way of quickly<br>
| examining and displaying multi-dimensional data. This technique is usually most<br>
| useful in the early stages of analysis when you're trying to get an understanding of<br>
| the data, e.g., finding some pattern or relationship between different factors or<br>
| variables. As the name suggests hierarchical clustering creates a hierarchy of<br>
| clusters.</p>
<p>...</p>
<p>|==                                                                           |   3%<br>
| Clustering organizes data points that are close into groups. So obvious questions<br>
| are "How do we define close?", "How do we group things?", and "How do we interpret<br>
| the grouping?" Cluster analysis is a very important topic in data analysis.</p>
<p>...</p>
<p>|====                                                                         |   5%<br>
| To give you an idea of what we're talking about, consider these random points we<br>
| generated. We'll use them to demonstrate hierarchical clustering in this lesson.<br>
| We'll do this in several steps, but first we have to clarify our terms and concepts.</p>
<p><img src="../images/r0041430.png" alt="image" title="image"><br>
...</p>
<p>|=====                                                                        |   6%<br>
| Hierarchical clustering is an agglomerative, or bottom-up, approach. From Wikipedia<br>
| (<a href="http://en.wikipedia.org/wiki/Hierarchical_clustering">http://en.wikipedia.org/wiki/Hierarchical_clustering</a>), we learn that in this<br>
| method, "each observation starts in its own cluster, and pairs of clusters are<br>
| merged as one moves up the hierarchy." This means that we'll find the closest two<br>
| points and put them together in one cluster, then find the next closest pair in the<br>
| updated picture, and so forth. We'll repeat this process until we reach a reasonable<br>
| stopping place.</p>
<p>...</p>
<p>|======                                                                       |   8%<br>
| Note the word "reasonable". There's a lot of flexibility in this field and how you<br>
| perform your analysis depends on your problem. Again, Wikipedia tells us, "one can<br>
| decide to stop clustering either when the clusters are too far apart to be merged<br>
| (distance criterion) or when there is a sufficiently small number of clusters<br>
| (number criterion)."</p>
<p>...</p>
<p>|=======                                                                      |  10%<br>
| First, how do we define close? This is the most important step and there are several<br>
| possibilities depending on the questions you're trying to answer and the data you<br>
| have. Distance or similarity are usually the metrics used.</p>
<p>...</p>
<p>|=========                                                                    |  11%<br>
| In the given plot which pair points would you first cluster? Use distance as the<br>
| metric.</p>
<p>1: 5 and 6<br>
2: 1 and 4<br>
3: 10 and 12<br>
4: 7 and 8</p>
<p>Selection: 1</p>
<p>| Perseverance, that's the answer.</p>
<p>|==========                                                                   |  13%<br>
| It's pretty obvious that out of the 4 choices, the pair 5 and 6 were the closest<br>
| together. However, there are several ways to measure distance or similarity.<br>
| Euclidean distance and correlation similarity are continuous measures, while<br>
| Manhattan distance is a binary measure. In this lesson we'll just briefly discuss<br>
| the first and last of these. It's important that you use a measure of distance that<br>
| fits your problem.</p>
<p>...</p>
<p>|===========                                                                  |  15%<br>
| Euclidean distance is what you learned about in high school algebra. Given two<br>
| points on a plane, (x1,y1) and (x2,y2), the Euclidean distance is the square root of<br>
| the sums of the squares of the distances between the two x-coordinates (x1-x2) and<br>
| the two y-coordinates (y1-y2). You probably recognize this as an application of the<br>
| Pythagorean theorem which yields the length of the hypotenuse of a right triangle.</p>
<p><img src="../images/r0041440.png" alt="image" title="image"><br>
...</p>
<p>|============                                                                 |  16%<br>
| It shouldn't be hard to believe that this generalizes to more than two dimensions as<br>
| shown in the formula at the bottom of the picture shown here.</p>
<p>...</p>
<p>|==============                                                               |  18%<br>
| Euclidean distance is distance "as the crow flies". Many applications, however,<br>
| can't realistically use crow-flying distance. Cars, for instance, have to follow<br>
| roads.</p>
<p>...</p>
<p>|===============                                                              |  19%<br>
| In this case, we can use Manhattan or city block distance (also known as a taxicab<br>
| metric). This picture, copied from <a href="http://en.wikipedia.org/wiki/Taxicab_geometry">http://en.wikipedia.org/wiki/Taxicab_geometry</a>,<br>
| shows what this means.</p>
<p><img src="../images/r0041450.png" alt="image" title="image"><br>
...</p>
<p>|================                                                             |  21%<br>
| You want to travel from the point at the lower left to the one on the top right. The<br>
| shortest distance is the Euclidean (the green line), but you're limited to the grid,<br>
| so you have to follow a path similar to those shown in red, blue, or yellow. These<br>
| all have the same length (12) which is the number of small gray segments covered by<br>
| their paths.</p>
<p>...</p>
<p>|=================                                                            |  23%<br>
| More formally, Manhattan distance is the sum of the absolute values of the distances<br>
| between each coordinate, so the distance between the points (x1,y1) and (x2,y2) is<br>
| |x1-x2|+|y1-y2|. As with Euclidean distance, this too generalizes to more than 2<br>
| dimensions.</p>
<p>...</p>
<p>|===================                                                          |  24%<br>
| Now we'll go back to our random points. You might have noticed that these points<br>
| don't really look randomly positioned, and in fact, they're not. They were actually<br>
| generated as 3 distinct clusters. We've put the coordinates of these points in a<br>
| data frame for you, called dataFrame.</p>
<p><img src="../images/r0041430.png" alt="image" title="image"><br>
...</p>
<p>|====================                                                         |  26%<br>
| We'll use this dataFrame to demonstrate an agglomerative (bottom-up) technique of<br>
| hierarchical clustering and create a dendrogram. This is an abstract picture (or<br>
| graph) which shows how the 12 points in our dataset cluster together. Two clusters<br>
| (initially, these are points) that are close are connected with a line, We'll use<br>
| Euclidean distance as our metric of closeness.</p>
<p>...</p>
<p>|=====================                                                        |  27%<br>
| Run the R command dist with the argument dataFrame to compute the distances between<br>
| all pairs of these points. By default dist uses Euclidean distance as its metric,<br>
| but other metrics such as Manhattan, are available. Just use the default.</p>
<blockquote>
<p>dist(dataFrame)</p>

<pre><code>            1          2          3          4          5          6          7  
2  0.34120511                                                                    
3  0.57493739 0.24102750                                                         
4  0.26381786 0.52578819 0.71861759                                              
5  1.69424700 1.35818182 1.11952883 1.80666768                                   
6  1.65812902 1.31960442 1.08338841 1.78081321 0.08150268                        
7  1.49823399 1.16620981 0.92568723 1.60131659 0.21110433 0.21666557             
8  1.99149025 1.69093111 1.45648906 2.02849490 0.61704200 0.69791931 0.65062566  
9  2.13629539 1.83167669 1.67835968 2.35675598 1.18349654 1.11500116 1.28582631  
10 2.06419586 1.76999236 1.63109790 2.29239480 1.23847877 1.16550201 1.32063059  
11 2.14702468 1.85183204 1.71074417 2.37461984 1.28153948 1.21077373 1.37369662  
12 2.05664233 1.74662555 1.58658782 2.27232243 1.07700974 1.00777231 1.17740375  
            8          9         10         11  
2                                               
3                                               
4                                               
5                                               
6                                               
7                                               
8                                               
9  1.76460709                                   
10 1.83517785 0.14090406                        
11 1.86999431 0.11624471 0.08317570             
12 1.66223814 0.10848966 0.19128645 0.20802789</code></pre>
<p>| Great job!</p>
</blockquote>
<p>|======================                                                       |  29%<br>
| You see that the output is a lower triangular matrix with rows numbered from 2 to 12<br>
| and columns numbered from 1 to 11. Entry (i,j) indicates the distance between points<br>
| i and j. Clearly you need only a lower triangular matrix since the distance between<br>
| points i and j equals that between j and i.</p>
<p>...</p>
<p>|========================                                                     |  31%<br>
| From the output of dist, what is the minimum distance between two points?</p>
<p>1: 0.08317<br>
2: -0.0700<br>
3: 0.1085<br>
4: 0.0815</p>
<p>Selection: 4</p>
<p>| Excellent job!</p>
<p>|=========================                                                    |  32%<br>
| So 0.0815 (units are unspecified) between points 5 and 6 is the shortest distance.<br>
| We can put these points in a single cluster and look for another close pair of<br>
| points.</p>
<p><img src="../images/r0041460.png" alt="image" title="image"><br>
...</p>
<p>|==========================                                                   |  34%<br>
| Looking at the picture, what would be another good pair of points to put in another<br>
| cluster given that 5 and 6 are already clustered?</p>
<p>1: 7 and the cluster containing 5 ad 6<br>
2: 10 and 11<br>
3: 7 and 8<br>
4: 1 and 4</p>
<p>Selection: 2</p>
<p>| You are amazing!</p>
<p>|===========================                                                  |  35%<br>
| So 10 and 11 are another pair of points that would be in a second cluster. We'll<br>
| start creating our dendrogram now. Here're the original plot and two beginning<br>
| pieces of the dendrogram.</p>
<p><img src="../images/r0041470.png" alt="image" title="image"><br>
...</p>
<p>|=============================                                                |  37%<br>
| We can keep going like this in the obvious way and pair up individual points, but as<br>
| luck would have it, R provides a simple function which you can call which creates a<br>
| dendrogram for you. It's called hclust() and takes as an argument the pairwise<br>
| distance matrix which we looked at before. We've stored this matrix for you in a<br>
| variable called distxy. Run hclust now with distxy as its argument and put the<br>
| result in the variable hc.</p>
<blockquote>
<p>hc&lt;-hclust(distxy)</p>
</blockquote>
<p>| Perseverance, that's the answer.</p>
<p>|==============================                                               |  39%<br>
| You're probably curious and want to see hc.</p>
<p>...</p>
<p>|===============================                                              |  40%<br>
| Call the R function plot with one argument, hc.</p>
<blockquote>
<p>plot(hc)</p>
</blockquote>
<p><img src="../images/r0041480.png" alt="image" title="image"></p>
<p>| That's correct!</p>
<p>|================================                                             |  42%<br>
| Nice plot, right? R's plot conveniently labeled everything for you. The points we<br>
| saw are the leaves at the bottom of the graph, 5 and 6 are connected, as are 10 and<br>
| 11. Moreover, we see that the original 3 groupings of points are closest together as<br>
| leaves on the picture. That's reassuring.  Now call plot again, this time with the<br>
| argument as.dendrogram(hc).</p>
<blockquote>
<p>plot(as.dendrogram(hc))</p>
</blockquote>
<p><img src="../images/r0041490.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|==================================                                           |  44%<br>
| The essentials are the same, but the labels are missing and the leaves (original<br>
| points) are all printed at the same level. Notice that the vertical heights of the<br>
| lines and labeling of the scale on the left edge give some indication of distance.<br>
| Use the R command abline to draw a horizontal blue line at 1.5 on this plot. Recall<br>
| that this requires 2 arguments, h=1.5 and col="blue".</p>
<blockquote>
<p>abline(h=1.5,col="blue")</p>
</blockquote>
<p>| Keep working like that and you'll get there!</p>
<p>|===================================                                          |  45%<br>
| We see that this blue line intersects 3 vertical lines and this tells us that using<br>
| the distance 1.5 (unspecified units) gives us 3 clusters (1 through 4), (9 through<br>
| 12), and (5 through 8). We call this a "cut" of our dendrogram. Now cut the<br>
| dendrogam by drawing a red horizontal line at .4.</p>
<blockquote>
<p>abline(h=0.4,col="red")</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|====================================                                         |  47%<br>
| How many clusters are there with a cut at this distance?</p>
<blockquote>
<p>5<br>
[1] 5</p>
</blockquote>
<p>| Keep up the great work!</p>
<p>|=====================================                                        |  48%<br>
| We see that by cutting at .4 we have 5 clusters, indicating that this distance is<br>
| small enough to break up our original grouping of points. If we drew a horizontal<br>
| line at .05, how many clusters would we get</p>
<blockquote>
<p>5<br>
[1] 5</p>
</blockquote>
<p>| That's not exactly what I'm looking for. Try again. Or, type info() for more<br>
| options.</p>
<p>| Recall that our shortest distance was around .08, so a distance smaller than that<br>
| would make all the points their own private clusters.</p>
<blockquote>
<p>12<br>
[1] 12</p>
</blockquote>
<p>| Perseverance, that's the answer.</p>
<p>|======================================                                       |  50%<br>
| Try it now (draw a horizontal line at .05) and make the line green.</p>
<blockquote>
<p>abline(h=0.05,col="green")</p>
</blockquote>
<p>| Your dedication is inspiring!</p>
<p>|========================================                                     |  52%<br>
| So the number of clusters in your data depends on where you draw the line! (We said<br>
| there's a lot of flexibility here.) Now that we've seen the practice, let's go back<br>
| to some "theory". Notice that the two original groupings, 5 through 8, and 9 through<br>
| 12, are connected with a horizontal line near the top of the display. You're<br>
| probably wondering how distances between clusters of points are measured.</p>
<p>...</p>
<p>|=========================================                                    |  53%<br>
| There are several ways to do this. We'll just mention two. The first is called<br>
| complete linkage and it says that if you're trying to measure a distance between two<br>
| clusters, take the greatest distance between the pairs of points in those two<br>
| clusters. Obviously such pairs contain one point from each cluster.</p>
<p>...</p>
<p>|==========================================                                   |  55%<br>
| So if we were measuring the distance between the two clusters of points (1 through<br>
| 4) and (5 through 8), using complete linkage as the metric we would use the distance<br>
| between points 4 and 8 as the measure since this is the largest distance between the<br>
| pairs of those groups.</p>
<p><img src="../images/r0041500.png" alt="image" title="image"><br>
...</p>
<p>|===========================================                                  |  56%<br>
| The distance between the two clusters of points (9 through 12) and (5 through 8),<br>
| using complete linkage as the metric, is the distance between points 11 and 8 since<br>
| this is the largest distance between the pairs of those groups.</p>
<p>...</p>
<p>|=============================================                                |  58%<br>
| As luck would have it, the distance between the two clusters of points (9 through<br>
| 12) and (1 through 4), using complete linkage as the metric, is the distance between<br>
| points 11 and 4.</p>
<p>...</p>
<p>|==============================================                               |  60%<br>
| We've created the dataframe dFsm for you containing these 3 points, 4, 8, and 11.<br>
| Run dist on dFsm to see what the smallest distance between these 3 points is.</p>
<blockquote>
<p>dist(dFsm)<br>
         1        2<br>
2 2.028495<br>
3 2.374620 1.869994</p>
</blockquote>
<p>| Keep up the great work!</p>
<p>|===============================================                              |  61%<br>
| We see that the smallest distance is between points 2 and 3 in this reduced set,<br>
| (these are actually points 8 and 11 in the original set), indicating that the two<br>
| clusters these points represent ((5 through 8) and (9 through 12) respectively)<br>
| would be joined (at a distance of 1.869) before being connected with the third<br>
| cluster (1 through 4). This is consistent with the dendrogram we plotted.</p>
<p><img src="../images/r0041510.png" alt="image" title="image"><br>
...</p>
<p>|================================================                             |  63%<br>
| The second way to measure a distance between two clusters that we'll just mention is<br>
| called average linkage. First you compute an "average" point in each cluster (think<br>
| of it as the cluster's center of gravity). You do this by computing the mean<br>
| (average) x and y coordinates of the points in the cluster.</p>
<p>...</p>
<p>|==================================================                           |  65%<br>
| Then you compute the distances between each cluster average to compute the<br>
| intercluster distance.</p>
<p><img src="../images/r0041520.png" alt="image" title="image"><br>
...</p>
<p>|===================================================                          |  66%<br>
| Now look at the hierarchical cluster we created before, hc.</p>
<blockquote>
<p>hc</p>
</blockquote>
<p>Call:<br>
hclust(d = distxy)</p>
<p>Cluster method   : complete<br>
Distance         : euclidean<br>
Number of objects: 12</p>
<p>| Excellent work!</p>
<p>|====================================================                         |  68%<br>
| Which type of linkage did hclust() use to agglomerate clusters?</p>
<p>1: complete<br>
2: average</p>
<p>Selection: 1</p>
<p>| You nailed it! Good job!</p>
<p>|=====================================================                        |  69%<br>
| In our simple set of data, the average and complete linkages aren't that different,<br>
| but in more complicated datasets the type of linkage you use could affect how your<br>
| data clusters. It is a good idea to experiment with different methods of linkage to<br>
| see the varying ways your data groups. This will help you determine the best way to<br>
| continue with your analysis.</p>
<p>...</p>
<p>|=======================================================                      |  71%<br>
| The last method of visualizing data we'll mention in this lesson concerns heat maps.<br>
| Wikipedia (<a href="http://en.wikipedia.org/wiki/Heat_map">http://en.wikipedia.org/wiki/Heat_map</a>) tells us a heat map is "a<br>
| graphical representation of data where the individual values contained in a matrix<br>
| are represented as colors. ... Heat maps originated in 2D displays of the values in<br>
| a data matrix. Larger values were represented by small dark gray or black squares<br>
| (pixels) and smaller values by lighter squares."</p>
<p>...</p>
<p>|========================================================                     |  73%<br>
| You've probably seen many examples of heat maps, for instance weather radar and<br>
| displays of ocean salinity. From Wikipedia (<a href="http://en.wikipedia.org/wiki/Heat_map">http://en.wikipedia.org/wiki/Heat_map</a>)<br>
| we learn that heat maps are often used in molecular biology "to represent the level<br>
| of expression of many genes across a number of comparable samples (e.g. cells in<br>
| different states, samples from different patients) as they are obtained from DNA<br>
| microarrays."</p>
<p>...</p>
<p>|=========================================================                    |  74%<br>
| We won't say too much on this topic, but a very nice concise tutorial on creating<br>
| heatmaps in R exists at<br>
| <a href="http://sebastianraschka.com/Articles/heatmaps_in_r.html#clustering">http://sebastianraschka.com/Articles/heatmaps_in_r.html#clustering</a>. Here's an image<br>
| from the tutorial to start you thinking about the topic. It shows a sample heat map<br>
| with a dendrogram on the left edge mapping the relationship between the rows. The<br>
| legend at the top shows how colors relate to values.</p>
<p><img src="../images/r0041530.png" alt="image" title="image"><br>
...</p>
<p>|==========================================================                   |  76%<br>
| R provides a handy function to produce heat maps. It's called heatmap. We've put the<br>
| point data we've been using throughout this lesson in a matrix. Call heatmap now<br>
| with 2 arguments. The first is dataMatrix and the second is col set equal to<br>
| cm.colors(25). This last is optional, but we like the colors better than the default<br>
| ones.</p>
<blockquote>
<p>heatmap(dataMatrix,col=cm.colors(25))</p>
</blockquote>
<p><img src="../images/r0041540.png" alt="image" title="image"></p>
<p>| That's a job well done!</p>
<p>|============================================================                 |  77%<br>
| We see an interesting display of sorts. This is a very simple heat map - simple<br>
| because the data isn't very complex. The rows and columns are grouped together as<br>
| shown by colors. The top rows (labeled 5, 6, and 7) seem to be in the same group<br>
| (same colors) while 8 is next to them but colored differently. This matches the<br>
| dendrogram shown on the left edge. Similarly, 9, 12, 11, and 10 are grouped together<br>
| (row-wise) along with 3 and 2. These are followed by 1 and 4 which are in a separate<br>
| group. Column data is treated independently of rows but is also grouped.</p>
<p>...</p>
<p>|=============================================================                |  79%<br>
| We've subsetted some vehicle data from mtcars, the Motor Trend Car Road Tests which<br>
| is part of the package datasets. The data is in the matrix mt and contains 6 factors<br>
| of 11 cars. Run heatmap now with mt as its only argument.</p>
<blockquote>
<p>heatmap(mt)</p>
</blockquote>
<p><img src="../images/r0041550.png" alt="image" title="image"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|==============================================================               |  81%<br>
| This looks slightly more interesting than the heatmap for the point data. It shows a<br>
| little better how the rows and columns are treated (clustered and colored)<br>
| independently of one another. To understand the disparity in color (between the left<br>
| 4 columns and the right 2) look at mt now.</p>
<blockquote>
<p>mt</p>

<pre><code>                  mpg cyl  disp  hp drat    wt  
Dodge Challenger 15.5   8 318.0 150 2.76 3.520  
AMC Javelin      15.2   8 304.0 150 3.15 3.435  
Camaro Z28       13.3   8 350.0 245 3.73 3.840  
Pontiac Firebird 19.2   8 400.0 175 3.08 3.845  
Fiat X1-9        27.3   4  79.0  66 4.08 1.935  
Porsche 914-2    26.0   4 120.3  91 4.43 2.140  
Lotus Europa     30.4   4  95.1 113 3.77 1.513  
Ford Pantera L   15.8   8 351.0 264 4.22 3.170  
Ferrari Dino     19.7   6 145.0 175 3.62 2.770  
Maserati Bora    15.0   8 301.0 335 3.54 3.570  
Volvo 142E       21.4   4 121.0 109 4.11 2.780</code></pre>
<p>| You're the best!</p>
</blockquote>
<p>|===============================================================              |  82%<br>
| See how four of the columns are all relatively small numbers and only two (disp and<br>
| hp) are large? That explains the big difference in color columns. Now to understand<br>
| the grouping of the rows call plot with one argument, the dendrogram object denmt<br>
| we've created for you.</p>
<blockquote>
<p>plot(denmt)</p>
</blockquote>
<p><img src="../images/r0041560.png" alt="image" title="image"></p>
<p>| Excellent work!</p>
<p>|=================================================================            |  84%<br>
| We see that this dendrogram is the one displayed at the side of the heat map. How<br>
| was this created? Recall that we generalized the distance formula for more than 2<br>
| dimensions. We've created a distance matrix for you, distmt. Look at it now.</p>
<blockquote>
<p>distmt</p>

<pre><code>                 Dodge Challenger AMC Javelin Camaro Z28 Pontiac Firebird Fiat X1-9  
AMC Javelin              14.00890                                                    
Camaro Z28              100.27404   105.57041                                        
Pontiac Firebird         85.80733    99.28330   86.22779                             
Fiat X1-9               253.64640   240.51305  325.11191        339.12867            
Porsche 914-2           206.63309   193.29419  276.87318        292.15588  48.29642  
Lotus Europa            226.48724   212.74240  287.59666        311.37656  49.78046  
Ford Pantera L          118.69012   123.31494   19.20778        101.66275 336.65679  
Ferrari Dino            174.86264   161.03078  216.72821        255.01117 127.67016  
Maserati Bora           185.78176   185.02489  102.48902        188.19917 349.02042  
Volvo 142E              201.35337   187.68535  266.49555        286.74036  60.40302  
                 Porsche 914-2 Lotus Europa Ford Pantera L Ferrari Dino Maserati Bora  
AMC Javelin                                                                            
Camaro Z28                                                                             
Pontiac Firebird                                                                       
Fiat X1-9                                                                              
Porsche 914-2                                                                          
Lotus Europa          33.75246                                                         
Ford Pantera L       288.56998    297.51961                                            
Ferrari Dino          87.81135     80.33743      224.44761                             
Maserati Bora        303.85577    303.20992       86.84620    223.52346                
Volvo 142E            18.60543     27.74042      277.43923     70.27895     289.02233</code></pre>
<p>| You nailed it! Good job!</p>
</blockquote>
<p>|==================================================================           |  85%<br>
| See how these distances match those in the dendrogram?  So hclust really works!<br>
| Let's review now.</p>
<p>...</p>
<p>|===================================================================          |  87%<br>
| What is the purpose of hierarchical clustering?</p>
<p>1: Inspire other researchers<br>
2: Give an idea of the relationships between variables or observations<br>
3: None of the others<br>
4: Present a finished picture</p>
<p>Selection:<br>
Enter an item from the menu, or 0 to exit<br>
Selection: 2</p>
<p>| You are amazing!</p>
<p>|====================================================================         |  89%<br>
| True or False? When you're doing hierarchical clustering there are strict rules that<br>
| you MUST follow.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| You got it!</p>
<p>|======================================================================       |  90%<br>
| True or False? There's only one way to measure distance.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| Excellent work!</p>
<p>|=======================================================================      |  92%<br>
| True or False? Complete linkage is a method of computing distances between clusters.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 1</p>
<p>| That's a job well done!</p>
<p>|========================================================================     |  94%<br>
| True or False? Average linkage uses the maximum distance between points of two<br>
| clusters as the distance between those clusters.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| You nailed it! Good job!</p>
<p>|=========================================================================    |  95%<br>
| True or False? The number of clusters you derive from your data depends on the<br>
| distance at which you choose to cut it.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 1</p>
<p>| Your dedication is inspiring!</p>
<p>|===========================================================================  |  97%<br>
| True or False? Once you decide basics, such as defining a distance metric and<br>
| linkage method, hierarchical clustering is deterministic.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 1</p>
<p>| You nailed it! Good job!</p>
<p>|============================================================================ |  98%<br>
| Congratulations! We hope this lesson didn't fluster you or get you too heated!</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: No<br>
2: Yes</p>
<p>Selection: 2<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| That's the answer I was looking for.</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-09 20:05:13.711728 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00428/" class="u-url">GGPlot2 Extras</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00428/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-09T20:00:06+05:30" itemprop="datePublished" title="2020-05-09 20:00">2020-05-09 20:00</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00428/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00428_GGPlot2 Extras.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00428_GGPlot2 Extras.html";
var idcomments_post_url = "/posts/00428/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 4.0.0 (2020-04-24) -- "Arbor Day"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>Natural language support but running in an English locale</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<blockquote>
<p>setwd("C:/images")<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>

<pre><code> 1: Principles of Analytic Graphs   2: Exploratory Graphs             
 3: Graphics Devices in R           4: Plotting Systems               
 5: Base Plotting System            6: Lattice Plotting System        
 7: Working with Colors             8: GGPlot2 Part1                  
 9: GGPlot2 Part2                  10: GGPlot2 Extras                 
11: Hierarchical Clustering        12: K Means Clustering             
13: Dimension Reduction            14: Clustering Example             
15: CaseStudy</code></pre>
<p>Selection: 10</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>|                                                                             |   0%</p>
<p>| GGPlot2_Extras. (Slides for this and other Data Science courses may be found at<br>
| github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use<br>
| them, they must be downloaded as a zip file and viewed locally. This lesson<br>
| corresponds to 04_ExploratoryAnalysis/ggplot2.)</p>
<p>...</p>
<p>|=                                                                            |   2%<br>
| In this lesson we'll go through a few more qplot examples using diamond data which<br>
| comes with the ggplot2 package. This data is a little more complicated than the mpg<br>
| data and it contains information on various characteristics of diamonds.</p>
<p>...</p>
<p>|===                                                                          |   4%<br>
| Run the R command str with the argument diamonds to see what the data looks like.</p>
<blockquote>
<p>str(diamonds)</p>

<pre><code>tibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)  
 $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...  
 $ cut    : Ord.factor w/ 5 levels "Fair"&lt;"Good"&lt;..: 5 4 2 4 2 3 3 3 1 3 ...  
 $ color  : Ord.factor w/ 7 levels "D"&lt;"E"&lt;"F"&lt;"G"&lt;..: 2 2 2 6 7 7 6 5 2 5 ...  
 $ clarity: Ord.factor w/ 8 levels "I1"&lt;"SI2"&lt;"SI1"&lt;..: 2 3 5 4 2 6 7 3 4 5 ...  
 $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...  
 $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...  
 $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...  
 $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...  
 $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...  
 $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...</code></pre>
<p>| Keep working like that and you'll get there!</p>
</blockquote>
<p>|====                                                                         |   6%<br>
| From the output, how many characteristics of diamonds do you think this data<br>
| contains?</p>
<p>1: 53950<br>
2: 53940<br>
3: 10<br>
4: 5394</p>
<p>Selection: 3</p>
<p>| You are doing so well!</p>
<p>|======                                                                       |   7%<br>
| From the output of str, how many diamonds are characterized in this dataset?</p>
<p>1: 53950<br>
2: 10<br>
3: 5394<br>
4: 53940</p>
<p>Selection: 1</p>
<p>| You're close...I can feel it! Try it again.</p>
<p>| The output says there are 53940 observations of 10 variables. This is followed by a<br>
| 10-long list of characteristics (carat, cut, color, etc.) that can apply to<br>
| diamonds.</p>
<p>1: 5394<br>
2: 53940<br>
3: 10<br>
4: 53950</p>
<p>Selection: 2</p>
<p>| You got it!</p>
<p>|=======                                                                      |   9%<br>
| Now let's plot a histogram of the price of the 53940 diamonds in this dataset.<br>
| Recall that a histogram requires only one variable of the data, so run the R command<br>
| qplot with the first argument price and the argument data set equal to diamonds.<br>
| This will show the frequency of different diamond prices.</p>
<blockquote>
<p>qplot(price,data=diamonds)<br><code>stat_bin()</code> using <code>bins = 30</code>. Pick better value with <code>binwidth</code>.</p>
</blockquote>
<p><img src="../images/r0041290.png" alt="image" title="image"></p>
<p>| Excellent work!</p>
<p>|=========                                                                    |  11%<br>
| Not only do you get a histogram, but you also get a message about the binwidth<br>
| defaulting to range/30. Recall that range refers to the spread or dispersion of the<br>
| data, in this case price of diamonds. Run the R command range now with<br>
| diamonds$price as its argument.</p>
<blockquote>
<p>range(diamonds$price)<br>
[1]   326 18823</p>
</blockquote>
<p>| You nailed it! Good job!</p>
<p>|==========                                                                   |  13%<br>
| We see that range returned the minimum and maximum prices, so the diamonds vary in<br>
| price from $326 to $18823. We've done the arithmetic for you, the range (difference<br>
| between these two numbers) is $18497.</p>
<p>...</p>
<p>|===========                                                                  |  15%<br>
| Rerun qplot now with 3 arguments. The first is price, the second is data set equal<br>
| to diamonds, and the third is binwidth set equal to 18497/30). (Use the up arrow to<br>
| save yourself some typing.) See if the plot looks familiar.</p>
<blockquote>
<p>qplot(price,data=diamonds,binwidth=18497/30)</p>
</blockquote>
<p><img src="../images/r0041300.png" alt="image" title="image"></p>
<p>| All that practice is paying off!</p>
<p>|=============                                                                |  17%<br>
| No more messages in red, but a histogram almost identical to the previous one! If<br>
| you typed 18497/30 at the command line you would get the result 616.5667. This means<br>
| that the height of each bin tells you how many diamonds have a price between x and<br>
| x+617 where x is the left edge of the bin.</p>
<p>...</p>
<p>|==============                                                               |  19%<br>
| We've created a vector containing integers that are multiples of 617 for you. It's<br>
| called brk. Look at it now.</p>
<blockquote>
<p>brk</p>

<pre><code> [1]     0   617  1234  1851  2468  3085  3702  4319  4936  5553  6170  6787  7404  
[14]  8021  8638  9255  9872 10489 11106 11723 12340 12957 13574 14191 14808 15425  
[27] 16042 16659 17276 17893 18510 19127</code></pre>
<p>| You are amazing!</p>
</blockquote>
<p>|================                                                             |  20%<br>
| We've also created a vector containing the number of diamonds with prices between<br>
| each pair of adjacent entries of brk. For instance, the first count is the number of<br>
| diamonds with prices between 0 and $617, and the second is the number of diamonds  
| with prices between $617 and $1234. Look at the vector named counts now.</p>
<blockquote>
<p>counts</p>

<pre><code> [1]  4611 13255  5230  4262  3362  2567  2831  2841  2203  1666  1445  1112   987  
[14]   766   796   655   606   553   540   427   429   376   348   338   298   305  
[27]   269   287   227   251    97</code></pre>
<p>| You nailed it! Good job!</p>
</blockquote>
<p>|=================                                                            |  22%<br>
| See how it matches the histogram you just plotted? So, qplot really works!</p>
<p>...</p>
<p>|===================                                                          |  24%<br>
| You're probably sick of it but rerun qplot again, this time with 4 arguments. The<br>
| first 3 are the same as the last qplot command you just ran (price, data set equal<br>
| to diamonds, and binwidth set equal to 18497/30). (Use the up arrow to save yourself<br>
| some typing.) The fourth argument is fill set equal to cut. The shape of the<br>
| histogram will be familiar, but it will be more colorful.</p>
<blockquote>
<p>qplot(price,data=diamonds,binwidth=18497/30,fill=cut)</p>
</blockquote>
<p><img src="../images/r0041310.png" alt="image" title="image"></p>
<p>| You're the best!</p>
<p>|====================                                                         |  26%<br>
| This shows how the counts within each price grouping (bin) are distributed among the<br>
| different cuts of diamonds. Notice how qplot displays these distributions relative<br>
| to the cut legend on the right. The fair cut diamonds are at the bottom of each bin,<br>
| the good cuts are above them, then the very good above them, until the ideal cuts<br>
| are at the top of each bin. You can quickly see from this display that there are<br>
| very few fair cut diamonds priced above $5000.</p>
<p>...</p>
<p>|=====================                                                        |  28%<br>
| Now we'll replot the histogram as a density function which will show the proportion<br>
| of diamonds in each bin. This means that the shape will be similar but the scale on<br>
| the y-axis will be different since, by definition, the density function is<br>
| nonnegative everywhere, and the area under the curve is one. To do this, simply call<br>
| qplot with 3 arguments. The first 2 are price and data (set equal to diamonds). The<br>
| third is geom which should be set equal to the string "density". Try this now.</p>
<blockquote>
<p>qplot(price,data=diamonds,geom="density")</p>
</blockquote>
<p><img src="../images/r0041320.png" alt="image" title="image"></p>
<p>| Your dedication is inspiring!</p>
<p>|=======================                                                      |  30%<br>
| Notice that the shape is similar to that of the histogram we saw previously. The<br>
| highest peak is close to 0 on the x-axis meaning that most of the diamonds in the<br>
| dataset were inexpensive. In general, as prices increase (move right along the<br>
| x-axis) the number of diamonds (at those prices) decrease. The exception to this is<br>
| when the price is around $4000; there's a slight increase in frequency. Let's see if<br>
| cut is responsible for this increase.</p>
<p>...</p>
<p>|========================                                                     |  31%<br>
| Rerun qplot, this time with 4 arguments. The first 2 are the usual, and the third is<br>
| geom set equal to "density". The fourth is color set equal to cut. Try this now.</p>
<blockquote>
<p>qplot(price,data=diamonds,geom="density",color=cut)</p>
</blockquote>
<p><img src="../images/r0041330.png" alt="image" title="image"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|==========================                                                   |  33%<br>
| See how easily qplot did this? Four of the five cuts have 2 peaks, one at price<br>
| $1000 and the other between $4000 and $5000. The exception is the Fair cut which has  
| a single peak at $2500. This gives us a little more understanding of the histogram<br>
| we saw before.</p>
<p>...</p>
<p>|===========================                                                  |  35%<br>
| Let's move on to scatterplots. For these we'll need to specify two variables from<br>
| the diamond dataset.</p>
<p>...</p>
<p>|=============================                                                |  37%<br>
| Let's start with carat and price. Use these as the first 2 arguments of qplot. The<br>
| third should be data set equal to the dataset. Try this now.</p>
<blockquote>
<p>qplot(carat,price,data=diamonds)</p>
</blockquote>
<p><img src="../images/r0041340.png" alt="image" title="image"></p>
<p>| You got it right!</p>
<p>|==============================                                               |  39%<br>
| We see the positive trend here, as the number of carats increases the price also<br>
| goes up.</p>
<p>...</p>
<p>|===============================                                              |  41%<br>
| Now rerun the same command, except add a fourth parameter, shape, set equal to cut.</p>
<blockquote>
<p>qplot(carat,price,data=diamonds,shape=cut)<br>
Warning message:<br>
Using shapes for an ordinal variable is not advised</p>
</blockquote>
<p><img src="../images/r0041350.png" alt="image" title="image"></p>
<p>| You are doing so well!</p>
<p>|=================================                                            |  43%<br>
| The same scatterplot appears, except the cuts of the diamonds are distinguished by<br>
| different symbols. The legend at the right tells you which symbol is associated with<br>
| each cut. These are small and hard to read, so rerun the same command, except this<br>
| time instead of setting the argument shape equal to cut, set the argument color<br>
| equal to cut.</p>
<blockquote>
<p>qplot(carat,price,data=diamonds,color=cut)</p>
</blockquote>
<p><img src="../images/r0041360.png" alt="image" title="image"></p>
<p>| Excellent job!</p>
<p>|==================================                                           |  44%<br>
| That's easier to see! Now we'll close with two, more complicated scatterplot<br>
| examples.</p>
<p>...</p>
<p>|====================================                                         |  46%<br>
| We'll rerun the plot you just did (carat,price,data=diamonds and color=cut) but add<br>
| an additional parameter. Use geom_smooth with the method set equal to the string<br>
| "lm".</p>
<blockquote>
<p>qplot(carat,price,data=diamonds,color=cut)+geom_smooth(method="lm")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041370.png" alt="image" title="image"></p>
<p>| That's a job well done!</p>
<p>|=====================================                                        |  48%<br>
| Again, we see the same scatterplot, but slightly more compressed and showing 5<br>
| regression lines, one for each cut of diamonds. It might be hard to see, but around<br>
| each line is a shadow showing the 95% confidence interval. We see, unsurprisingly,<br>
| that the better the cut, the steeper (more positive) the slope of the lines.</p>
<p>...</p>
<p>|======================================                                       |  50%<br>
| Finally, let's rerun that plot you just did qplot(carat,price,data=diamonds,<br>
| color=cut) + geom_smooth(method="lm") but add one (just one) more argument to qplot.<br>
| The new argument is facets and it should be set equal to the formula .~cut. Recall<br>
| that the facets argument indicates we want a multi-panel plot. The symbol to the<br>
| left of the tilde indicates rows (in this case just one) and the symbol to the right<br>
| of the tilde indicates columns (in this five, the number of cuts). Try this now.</p>
<blockquote>
<p>qplot(carat,price,data=diamonds,color=cut,facets=.~cut)+geom_smooth(method="lm")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041380.png" alt="image" title="image"></p>
<p>| You are quite good my friend!</p>
<p>|========================================                                     |  52%<br>
| Pretty good, right? Not too difficult either. Let's review what we learned!</p>
<p>...</p>
<p>|=========================================                                    |  54%<br>
| Which types of plot does qplot plot?</p>
<p>1: box and whisker plots<br>
2: histograms<br>
3: all of the others<br>
4: scatterplots</p>
<p>Selection: 3</p>
<p>| You are doing so well!</p>
<p>|===========================================                                  |  56%<br>
| Any and all of the above choices work; qplot is just that good. What does the gg in<br>
| ggplot2 stand for?</p>
<p>1: good grief<br>
2: goto graphics<br>
3: grammar of graphics<br>
4: good graphics</p>
<p>Selection: 3</p>
<p>| You are amazing!</p>
<p>|============================================                                 |  57%<br>
| True or False? The geom argument takes a string for a value.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| You are really on a roll!</p>
<p>|==============================================                               |  59%<br>
| True or False? The method argument takes a string for a value.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 1</p>
<p>| You got it!</p>
<p>|===============================================                              |  61%<br>
| True or False? The binwidth argument takes a string for a value.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| You nailed it! Good job!</p>
<p>|================================================                             |  63%<br>
| True or False? The user must specify x- and y-axis labels when using qplot.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| That's correct!</p>
<p>|==================================================                           |  65%<br>
| Now for some ggplots.</p>
<p>...</p>
<p>|===================================================                          |  67%<br>
| First create a graphical object g by assigning to it the output of a call to the<br>
| function ggplot with 2 arguments. The first is the dataset diamonds and the second<br>
| is a call to the function aes with 2 arguments, depth and price. Remember you won't<br>
| see any result.</p>
<blockquote>
<p>g&lt;-ggplot(data=diamonds,aes(depth,price))</p>
</blockquote>
<p>| You are quite good my friend!</p>
<p>|=====================================================                        |  69%<br>
| Does g exist? Yes! Type summary with g as an argument to see what it holds.</p>
<blockquote>
<p>summary(g)</p>

<pre><code>data: carat, cut, color, clarity, depth, table, price, x, y, z [53940x10]  
mapping:  x = ~depth, y = ~price  
faceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt;  
    compute_layout: function  
    draw_back: function  
    draw_front: function  
    draw_labels: function  
    draw_panels: function  
    finish_data: function  
    init_scales: function  
    map_data: function  
    params: list  
    setup_data: function  
    setup_params: function  
    shrink: TRUE  
    train_scales: function  
    vars: function  
    super:  &lt;ggproto object: Class FacetNull, Facet, gg&gt;</code></pre>
<p>| That's a job well done!</p>
</blockquote>
<p>|======================================================                       |  70%<br>
| We see that g holds the entire dataset. Now suppose we want to see a scatterplot of<br>
| the relationship. Add to g a call to the function geom_point with 1 argument, alpha<br>
| set equal to 1/3.</p>
<blockquote>
<p>g+geom_point(alpha=1/3)</p>
</blockquote>
<p><img src="../images/r0041390.png" alt="image" title="image"></p>
<p>| You're the best!</p>
<p>|========================================================                     |  72%<br>
| That's somewhat interesting. We see that depth ranges from 43 to 79, but the densest<br>
| distribution is around 60 to 65. Suppose we want to see if this relationship<br>
| (between depth and price) is affected by cut or carat. We know cut is a factor with<br>
| 5 levels (Fair, Good, Very Good, Premium, and Ideal). But carat is numeric and not a<br>
| discrete factor. Can we do this?</p>
<p>...</p>
<p>|=========================================================                    |  74%<br>
| Of course! That's why we asked. R has a handy command, cut, which allows you to<br>
| divide your data into sets and label each entry as belonging to one of the sets, in<br>
| effect creating a new factor. First, we'll have to decide where to cut the data.</p>
<p>...</p>
<p>|==========================================================                   |  76%<br>
| Let's divide the data into 3 pockets, so 1/3 of the data falls into each. We'll use<br>
| the R command quantile to do this. Create the variable cutpoints and assign to it<br>
| the output of a call to the function quantile with 3 arguments. The first is the<br>
| data to cut, namely diamonds$carat; the second is a call to the R function seq. This<br>
| is also called with 3 arguments, (0, 1, and length set equal to 4). The third<br>
| argument to the call to quantile is the boolean na.rm set equal to TRUE.</p>
<blockquote>
<p>cutpoints&lt;-quantile(diamonds$carat,seq(0,1,length=4),na.rm=TRUE)</p>
</blockquote>
<p>| Keep working like that and you'll get there!</p>
<p>|============================================================                 |  78%<br>
| Look at cutpoints now to understand what it is.</p>
<blockquote>
<p>cutpoints</p>
</blockquote>

<pre><code>   0% 33.33333% 66.66667%      100%   
 0.20      0.50      1.00      5.01   

</code></pre>
<p>| You got it right!</p>
<p>|=============================================================                |  80%<br>
| We see a 4-long vector (explaining why length was set equal to 4). We also see that<br>
| .2 is the smallest carat size in the dataset and 5.01 is the largest. One third of<br>
| the diamonds are between .2 and .5 carats and another third are between .5 and 1<br>
| carat in size. The remaining third are between 1 and 5.01 carats. Now we can use the<br>
| R command cut to label each of the 53940 diamonds in the dataset as belonging to one<br>
| of these 3 factors. Create a new name in diamonds, diamonds$car2 by assigning it the  
| output of the call to cut. This command takes 2 arguments, diamonds$carat, which is<br>
| what we want to cut, and cutpoints, the places where we'll cut.</p>
<blockquote>
<p>diamonds$car2&lt;-cut(diamonds$carat,cutpoints)</p>
</blockquote>
<p>| You are quite good my friend!</p>
<p>|===============================================================              |  81%<br>
| Now we can continue with our multi-facet plot. First we have to reset g since we<br>
| changed the dataset (diamonds) it contained (by adding a new column). Assign to g<br>
| the output of a call to ggplot with 2 arguments. The dataset diamonds is the first,<br>
| and a call to the function aes with 2 arguments (depth,price) is the second.</p>
<blockquote>
<p>g&lt;-ggplot(data=diamonds,aes(depth,price))</p>
</blockquote>
<p>| You're the best!</p>
<p>|================================================================             |  83%<br>
| Now add to g calls to 2 functions. This first is a call to geom_point with the<br>
| argument alpha set equal to 1/3. The second is a call to the function facet_grid<br>
| using the formula cut ~ car2 as its argument.</p>
<blockquote>
<p>g+geom_point(alpha=1/3)+facet_grid(cut~car2)</p>
</blockquote>
<p><img src="../images/r0041400.png" alt="image" title="image"></p>
<p>| That's correct!</p>
<p>|==================================================================           |  85%<br>
| We see a multi-facet plot with 5 rows, each corresponding to a cut factor. Not<br>
| surprising. What is surprising is the number of columns. We were expecting 3 and got<br>
| 4. Why?</p>
<p>...</p>
<p>|===================================================================          |  87%<br>
| The first 3 columns are labeled with the cutpoint boundaries. The fourth is labeled<br>
| NA and shows us where the data points with missing data (NA or Not Available)<br>
| occurred. We see that there were only a handful (12 in fact) and they occurred in<br>
| Very Good, Premium, and Ideal cuts. We created a vector, myd, containing the indices<br>
| of these datapoints. Look at these entries in diamonds by typing the expression<br>
| diamonds[myd,]. The myd tells R what rows to show and the empty column entry says to<br>
| print all the columns.</p>
<blockquote>
<p>diamonds[myd,]</p>

<pre><code># A tibble: 12 x 11  
   carat cut       color clarity depth table price     x     y     z car2   
   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  
 1   0.2 Premium   E     SI2      60.2    62   345  3.79  3.75  2.27 NA     
 2   0.2 Premium   E     VS2      59.8    62   367  3.79  3.77  2.26 NA     
 3   0.2 Premium   E     VS2      59      60   367  3.81  3.78  2.24 NA     
 4   0.2 Premium   E     VS2      61.1    59   367  3.81  3.78  2.32 NA     
 5   0.2 Premium   E     VS2      59.7    62   367  3.84  3.8   2.28 NA     
 6   0.2 Ideal     E     VS2      59.7    55   367  3.86  3.84  2.3  NA     
 7   0.2 Premium   F     VS2      62.6    59   367  3.73  3.71  2.33 NA     
 8   0.2 Ideal     D     VS2      61.5    57   367  3.81  3.77  2.33 NA     
 9   0.2 Very Good E     VS2      63.4    59   367  3.74  3.71  2.36 NA     
10   0.2 Ideal     E     VS2      62.2    57   367  3.76  3.73  2.33 NA     
11   0.2 Premium   D     VS2      62.3    60   367  3.73  3.68  2.31 NA     
12   0.2 Premium   D     VS2      61.7    60   367  3.77  3.72  2.31 NA</code></pre>
<p>| You're the best!</p>
</blockquote>
<p>|====================================================================         |  89%<br>
| We see these entries match the plots. Whew - that's a relief. The car2 field is, in<br>
| fact, NA for these entries, but the carat field shows they each had a carat size of<br>
| .2. What's going on here?</p>
<p>...</p>
<p>|======================================================================       |  91%<br>
| Actually our plot answers this question. The boundaries for each column appear in<br>
| the gray labels at the top of each column, and we see that the first column is<br>
| labeled (0.2,0.5]. This indicates that this column contains data greater than .2 and<br>
| less than or equal to .5. So diamonds with carat size .2 were excluded from the car2<br>
| field.</p>
<p>...</p>
<p>|=======================================================================      |  93%<br>
| Finally, recall the last plotting command<br>
| (g+geom_point(alpha=1/3)+facet_grid(cut~car2)) or retype it if you like and add<br>
| another call. This one to the function geom_smooth. Pass it 3 arguments, method set<br>
| equal to the string "lm", size set equal to 3, and color equal to the string "pink".</p>
<blockquote>
<p>play()</p>
</blockquote>
<p>| Entering play mode. Experiment as you please, then type nxt() when you are ready to<br>
| resume the lesson.</p>
<blockquote>
<p>diamonds[is.na(diamonds$car2),]</p>

<pre><code># A tibble: 12 x 11  
   carat cut       color clarity depth table price     x     y     z car2   
   &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  
 1   0.2 Premium   E     SI2      60.2    62   345  3.79  3.75  2.27 NA     
 2   0.2 Premium   E     VS2      59.8    62   367  3.79  3.77  2.26 NA     
 3   0.2 Premium   E     VS2      59      60   367  3.81  3.78  2.24 NA     
 4   0.2 Premium   E     VS2      61.1    59   367  3.81  3.78  2.32 NA     
 5   0.2 Premium   E     VS2      59.7    62   367  3.84  3.8   2.28 NA     
 6   0.2 Ideal     E     VS2      59.7    55   367  3.86  3.84  2.3  NA     
 7   0.2 Premium   F     VS2      62.6    59   367  3.73  3.71  2.33 NA     
 8   0.2 Ideal     D     VS2      61.5    57   367  3.81  3.77  2.33 NA     
 9   0.2 Very Good E     VS2      63.4    59   367  3.74  3.71  2.36 NA     
10   0.2 Ideal     E     VS2      62.2    57   367  3.76  3.73  2.33 NA     
11   0.2 Premium   D     VS2      62.3    60   367  3.73  3.68  2.31 NA     
12   0.2 Premium   D     VS2      61.7    60   367  3.77  3.72  2.31 NA</code></pre>
<p>nxt()</p>
</blockquote>
<p>| Resuming lesson...</p>
<p>| Finally, recall the last plotting command<br>
| (g+geom_point(alpha=1/3)+facet_grid(cut~car2)) or retype it if you like and add<br>
| another call. This one to the function geom_smooth. Pass it 3 arguments, method set<br>
| equal to the string "lm", size set equal to 3, and color equal to the string "pink".</p>
<blockquote>
<p>g+geom_point(alpha=1/3)+facet_grid(cut~car2)+geom_smooth(method="lm",size=3,color="pink")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041410.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|=========================================================================    |  94%<br>
| Nice thick regression lines which are somewhat interesting. You can add labels to<br>
| the plot if you want but we'll let you experiment on your own.</p>
<p>...</p>
<p>|==========================================================================   |  96%<br>
| Lastly, ggplot2 can, of course, produce boxplots. This final exercise is the sum of<br>
| 3 function calls. The first call is to ggplot with 2 arguments, diamonds and a call<br>
| to aes with carat and price as arguments. The second call is to geom_boxplot with no<br>
| arguments. The third is to facet_grid with one argument, the formula . ~ cut. Try<br>
| this now.</p>
<blockquote>
<p>ggplot(diamonds,aes(carat,price))+geom_boxplot()+facet_grid(.~cut)<br>
Warning message:<br>
Continuous y aesthetic -- did you forget aes(group=...)?</p>
</blockquote>
<p><img src="../images/r0041420.png" alt="image" title="image"></p>
<p>| Perseverance, that's the answer.</p>
<p>|============================================================================ |  98%<br>
| Yes! A boxplot looking like marshmallows about to be roasted. Well done and<br>
| congratulations! You've finished this jewel of a lesson. Hope it paid off!</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| Excellent job!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-09 22:04:44.535875 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00427/" class="u-url">GGPlot2 Part2</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00427/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-08T21:20:55+05:30" itemprop="datePublished" title="2020-05-08 21:20">2020-05-08 21:20</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00427/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00427_GGPlot2 Part2.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00427_GGPlot2 Part2.html";
var idcomments_post_url = "/posts/00427/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote>
<p>library(swirl)<br>
swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>

<pre><code> 1: Principles of Analytic Graphs   2: Exploratory Graphs             
 3: Graphics Devices in R           4: Plotting Systems               
 5: Base Plotting System            6: Lattice Plotting System        
 7: Working with Colors             8: GGPlot2 Part1                  
 9: GGPlot2 Part2                  10: GGPlot2 Extras                 
11: Hierarchical Clustering        12: K Means Clustering             
13: Dimension Reduction            14: Clustering Example             
15: CaseStudy</code></pre>
<p>Selection: 9</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>|                                                                              |   0%</p>
<p>| GGPlot2_Part2. (Slides for this and other Data Science courses may be found at github<br>
| <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use them, they<br>
| must be downloaded as a zip file and viewed locally. This lesson corresponds to<br>
| 04_ExploratoryAnalysis/ggplot2.)</p>
<p>...</p>
<p>|==                                                                            |   2%<br>
| In a previous lesson we showed you the vast capabilities of qplot, the basic<br>
| workhorse function of the ggplot2 package. In this lesson we'll focus on some<br>
| fundamental components of the package. These underlie qplot which uses default values<br>
| when it calls them. If you understand these building blocks, you will be better able<br>
| to customize your plots. We'll use the second workhorse function in the package,<br>
| ggplot, as well as other graphing functions.</p>
<p>...</p>
<p>|===                                                                           |   4%<br>
| Do you remember what the gg of ggplot2 stands for?</p>
<p>1: grammar of graphics<br>
2: good grief<br>
3: great graphics<br>
4: goto graphics</p>
<p>Selection: 1</p>
<p>| That's the answer I was looking for.</p>
<p>|=====                                                                         |   6%<br>
| A "grammar" of graphics means that ggplot2 contains building blocks with which you<br>
| can create your own graphical objects. What are these basic components of ggplot2<br>
| plots? There are 7 of them.</p>
<p>...</p>
<p>|======                                                                        |   8%<br>
| Obviously, there's a DATA FRAME which contains the data you're trying to plot. Then<br>
| the AESTHETIC MAPPINGS determine how data are mapped to color, size, etc. The GEOMS<br>
| (geometric objects) are what you see in the plot (points, lines, shapes) and FACETS<br>
| are the panels used in conditional plots. You've used these or seen them used in the<br>
| first ggplot2 (qplot) lesson.</p>
<p>...</p>
<p>|========                                                                      |  10%<br>
| There are 3 more. STATS are statistical transformations such as binning, quantiles,<br>
| and smoothing which ggplot2 applies to the data. SCALES show what coding an aesthetic<br>
| map uses (for example, male = red, female = blue). Finally, the plots are depicted on<br>
| a COORDINATE SYSTEM. When you use qplot these were taken care of for you.</p>
<p>...</p>
<p>|==========                                                                    |  12%<br>
| Do you remember what the "artist's palette" model means in the context of plotting?</p>
<p>1: we draw pictures<br>
2: we mix paints<br>
3: plots are built up in layers<br>
4: things get messy</p>
<p>Selection: 3</p>
<p>| You nailed it! Good job!</p>
<p>|===========                                                                   |  15%<br>
| As in the base plotting system (and in contrast to the lattice system), when building<br>
| plots with ggplot2, the plots are built up in layers, maybe in several steps. You can<br>
| plot the data, then overlay a summary (for instance, a regression line or smoother)<br>
| and then add any metadata and annotations you need.</p>
<p>...</p>
<p>|=============                                                                 |  17%<br>
| We'll keep using the mpg data that comes with the ggplot2 package. Recall the<br>
| versatility of qplot. Just as a refresher, call qplot now with 5 arguments. The first<br>
| 3 deal with data - displ, hwy, and data=mpg. The fourth is geom set equal to the<br>
| concatenation of the two strings, "point" and "smooth". The fifth is facets set equal<br>
| to the formula .~drv. Try this now.</p>
<blockquote>
<p>qplot(displ,hwy,data=mpg,geom=c("point","smooth"),facets=.~drv)<br><code>geom_smooth()</code> using method = 'loess' and formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041060.png" alt="image" title="image"></p>
<p>| You got it!</p>
<p>|===============                                                               |  19%<br>
| We see a 3 facet plot, one for each drive type (4, f, and r). Now we'll see how<br>
| ggplot works. We'll build up a similar plot using the basic components of the<br>
| package. We'll do this in a series of steps.</p>
<p>...</p>
<p>|================                                                              |  21%<br>
| First we'll create a variable g by assigning to it the output of a call to ggplot<br>
| with 2 arguments. The first is mpg (our dataset) and the second will tell ggplot what<br>
| we want to plot, in this case, displ and hwy. These are what we want our aesthetics<br>
| to represent so we enclose these as two arguments to the function aes. Try this now.</p>
<blockquote>
<p>g&lt;-ggplot(mpg,aes(displ,hwy))</p>
</blockquote>
<p>| You are quite good my friend!</p>
<p>|==================                                                            |  23%<br>
| Notice that nothing happened? As in the lattice system, ggplot created a graphical<br>
| object which we assigned to the variable g.</p>
<p>...</p>
<p>|====================                                                          |  25%<br>
| Run the R command summary with g as its argument to see what g contains.</p>
<blockquote>
<p>summary(g)</p>

<pre><code>data: manufacturer, model, displ, year, cyl, trans, drv, cty, hwy, fl, class  
  [234x11]  
mapping:  x = ~displ, y = ~hwy  
faceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt;  
    compute_layout: function  
    draw_back: function  
    draw_front: function  
    draw_labels: function  
    draw_panels: function  
    finish_data: function  
    init_scales: function  
    map_data: function  
    params: list  
    setup_data: function  
    setup_params: function  
    shrink: TRUE  
    train_scales: function  
    vars: function  
    super:  &lt;ggproto object: Class FacetNull, Facet, gg&gt;</code></pre>
<p>| You are quite good my friend!</p>
</blockquote>
<p>|=====================                                                         |  27%<br>
| So g contains the mpg data with all its named components in a 234 by 11 matrix. It<br>
| also contains a mapping, x (displ) and y (hwy) which you specified, and no faceting.</p>
<p>...</p>
<p>|=======================                                                       |  29%<br>
| Note that if you tried to print g with the expressions g or print(g) you'd get an<br>
| error! Even though it's a great package, ggplot doesn't know how to display the data<br>
| yet since you didn't specify how you wanted to see it. Now type g+geom_point() and<br>
| see what happens.</p>
<blockquote>
<p>g+geom_point()</p>
</blockquote>
<p><img src="../images/r0041070.png" alt="image" title="image"></p>
<p>| You are quite good my friend!</p>
<p>|========================                                                      |  31%<br>
| By calling the function geom_point you added a layer. By not assigning the expression<br>
| to a variable you displayed a plot. Notice that you didn't have to pass any arguments<br>
| to the function geom_point. That's because the object g has all the data stored in<br>
| it. (Remember you saw that when you ran summary on g before.) Now use the expression<br>
| you just typed (g + geom_point()) and add to it another layer, a call to<br>
| geom_smooth(). Notice the red message R gives you.</p>
<blockquote>
<p>g+geom_point()+geom_smooth()<br><code>geom_smooth()</code> using method = 'loess' and formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041080.png" alt="image" title="image"></p>
<p>| You got it!</p>
<p>|==========================                                                    |  33%<br>
| The gray shadow around the blue line is the confidence band. See how wide it is at<br>
| the right? Let's try a different smoothing function. Use the up arrow to recover the<br>
| expression you just typed, and instead of calling geom_smooth with no arguments, call<br>
| it with the argument method set equal to the string "lm".</p>
<blockquote>
<p>g+geom_point()+geom_smooth(method="lm")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041090.png" alt="image" title="image"></p>
<p>| Excellent work!</p>
<p>|============================                                                  |  35%<br>
| By changing the smoothing function to "lm" (linear model) ggplot2 generated a<br>
| regression line through the data. Now recall the expression you just used and add to<br>
| it another call, this time to the function facet_grid. Use the formula . ~ drv as it<br>
| argument. Note that this is the same type of formula used in the calls to qplot.</p>
<blockquote>
<p>g+geom_point()+geom_smooth(method="lm")+facet_grid(.~drv)<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041100.png" alt="image" title="image"></p>
<p>| Your dedication is inspiring!</p>
<p>|=============================                                                 |  38%<br>
| Notice how each panel is labeled with the appropriate factor. All the data associated<br>
| with 4-wheel drive cars is in the leftmost panel, front-wheel drive data is shown in<br>
| the middle panel, and rear-wheel drive data in the rightmost. Notice that this is<br>
| similar to the plot you created at the start of the lesson using qplot. (We used a<br>
| different smoothing function than previously.)</p>
<p>...</p>
<p>|===============================                                               |  40%<br>
| So far you've just used the default labels that ggplot provides. You can add your own<br>
| annotation using functions such as xlab(), ylab(), and ggtitle(). In addition, the<br>
| function labs() is more general and can be used to label either or both axes as well<br>
| as provide a title. Now recall the expression you just typed and add a call to the<br>
| function ggtitle with the argument "Swirl Rules!".</p>
<blockquote>
<p>g+geom_point()+geom_smooth(method="lm")+facet_grid(.~drv)+ggtitle("Swirl Rules!")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041110.png" alt="image" title="image"></p>
<p>| You are doing so well!</p>
<p>|================================                                              |  42%<br>
| Now that you've seen the basics we'll talk about customizing. Each of the “geom”<br>
| functions (e.g., _point and _smooth) has options to modify it. Also, the function<br>
| theme() can be used to modify aspects of the entire plot, e.g. the position of the<br>
| legend. Two standard appearance themes are included in ggplot. These are theme_gray()<br>
| which is the default theme (gray background with white grid lines) and theme_bw()<br>
| which is a plainer (black and white) color scheme.</p>
<p>...</p>
<p>|==================================                                            |  44%<br>
| Let's practice modifying aesthetics now. We'll use the graphic object g that we<br>
| already filled with mpg data and add a call to the function geom_point, but this time<br>
| we'll give geom_point 3 arguments. Set the argument color equal to "pink", the<br>
| argument size to 4, and the argument alpha to 1/2. Notice that all the arguments are<br>
| set equal to constants.</p>
<blockquote>
<p>g+geom_point(color="pink",size=4,alpha=0.5)</p>
</blockquote>
<p><img src="../images/r0041120.png" alt="image" title="image"></p>
<p>| You are doing so well!</p>
<p>|====================================                                          |  46%<br>
| Notice the different shades of pink? That's the result of the alpha aesthetic which<br>
| you set to 1/2. This aesthetic tells ggplot how transparent the points should be.<br>
| Darker circles indicate values hit by multiple data points.</p>
<p>...</p>
<p>|=====================================                                         |  48%<br>
| Now we'll modify the aesthetics so that color indicates which drv type each point<br>
| represents. Again, use g and add to it a call to the function geom_point with 3<br>
| arguments. The first is size set equal to 4, the second is alpha equal to 1/2. The<br>
| third is a call to the function aes with the argument color set equal to drv. Note<br>
| that you MUST use the function aes since the color of the points is data dependent<br>
| and not a constant as it was in the previous example.</p>
<blockquote>
<p>g+geom_point(size=4,alpha=0.5,aes(color=drv))</p>
</blockquote>
<p><img src="../images/r0041130.png" alt="image" title="image"></p>
<p>| That's a job well done!</p>
<p>|=======================================                                       |  50%<br>
| Notice the helpful legend on the right decoding the relationship between color and<br>
| drv.</p>
<p>...</p>
<p>|=========================================                                     |  52%<br>
| Now we'll practice modifying labels. Again, we'll use g and add to it calls to 3<br>
| functions. First, add a call to geom_point with an argument making the color<br>
| dependent on the drv type (as we did in the previous example). Second, add a call to<br>
| the function labs with the argument title set equal to "Swirl Rules!". Finally, add a<br>
| call to labs with 2 arguments, one setting x equal to "Displacement" and the other<br>
| setting y equal to "Hwy Mileage".</p>
<blockquote>
<p>g+geom_point(aes(color=drv))+labs(title="Swirl Rules!")+labs(x="Displacement",y="Hwy Mileage")</p>
</blockquote>
<p><img src="../images/r0041140.png" alt="image" title="image"></p>
<p>| You are amazing!</p>
<p>|==========================================                                    |  54%<br>
| Note that you could have combined the two calls to the function labs in the previous<br>
| example. Now we'll practice customizing the geom_smooth calls. Use g and add to it a<br>
| call to geom_point setting the color to drv type (remember to use the call to the aes<br>
| function), size set to 2 and alpha to 1/2. Then add a call to geom_smooth with 4<br>
| arguments. Set size equal to 4, linetype to 3, method to "lm", and se to FALSE.</p>
<blockquote>
<p>g+geom_point(aes(color=drv),size=2,alpha=0.5)+geom_smooth(size=4,linetype=3,method="lm",se=FALSE)<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041150.png" alt="image" title="image"></p>
<p>| Perseverance, that's the answer.</p>
<p>|============================================                                  |  56%<br>
| What did these arguments do? The method specified a linear regression (note the<br>
| negative slope indicating that the bigger the displacement the lower the gas<br>
| mileage), the linetype specified that it should be dashed (not continuous), the size<br>
| made the dashes big, and the se flag told ggplot to turn off the gray shadows<br>
| indicating standard errors (confidence intervals).</p>
<p>...</p>
<p>|=============================================                                 |  58%<br>
| Finally, let's do a simple plot using the black and white theme, theme_bw. Specify g<br>
| and add a call to the function geom_point with the argument setting the color to the<br>
| drv type. Then add a call to the function theme_bw with the argument base_family set<br>
| equal to "Times". See if you notice the difference.</p>
<blockquote>
<p>g+geom_point(aes(color=drv))+theme_bw(base_family = "Times")<br>
There were 13 warnings (use warnings() to see them)</p>
</blockquote>
<p><img src="../images/r0041160.png" alt="image" title="image"></p>
<p>| Nice work!</p>
<p>|===============================================                               |  60%<br>
| No more gray background! Also, if you have good eyesight, you'll notice that the font<br>
| in the labels changed.</p>
<p>...</p>
<p>|=================================================                             |  62%<br>
| One final note before we go through a more complicated, layered ggplot example, and<br>
| this concerns the limits of the axes. We're pointing this out to emphasize a subtle<br>
| difference between ggplot and the base plotting function plot.</p>
<p>...</p>
<p>|==================================================                            |  65%<br>
| We've created some random x and y data, called myx and myy, components of a dataframe<br>
| called testdat. These represent 100 random normal points, except halfway through, we<br>
| made one of the points be an outlier. That is, we set its y-value to be out of range<br>
| of the other points. Use the base plotting function plot to create a line plot of<br>
| this data. Call it with 4 arguments - myx, myy, type="l", and ylim=c(-3,3). The<br>
| type="l" tells plot you want to display the data as a line instead of as a<br>
| scatterplot.</p>
<p>warning messages from top-level task callback 'mini'<br>
There were 40 warnings (use warnings() to see them)</p>
<blockquote>
<p>play()</p>
</blockquote>
<p>| Entering play mode. Experiment as you please, then type nxt() when you are ready to<br>
| resume the lesson.</p>
<blockquote>
<p>g+geom_point(aes(color=drv))+theme_dark()</p>
</blockquote>
<p><img src="../images/r0041170.png" alt="image" title="image"></p>
<blockquote>
<p>g+geom_point(aes(color=drv))+theme_minimal()</p>
</blockquote>
<p><img src="../images/r0041180.png" alt="image" title="image"></p>
<blockquote>
<p>g+geom_point(aes(color=drv))+theme_grey()</p>
</blockquote>
<p><img src="../images/r0041190.png" alt="image" title="image"></p>
<blockquote>
<p>nxt()</p>
</blockquote>
<p>| Resuming lesson...</p>
<p>| We've created some random x and y data, called myx and myy, components of a dataframe<br>
| called testdat. These represent 100 random normal points, except halfway through, we<br>
| made one of the points be an outlier. That is, we set its y-value to be out of range<br>
| of the other points. Use the base plotting function plot to create a line plot of<br>
| this data. Call it with 4 arguments - myx, myy, type="l", and ylim=c(-3,3). The<br>
| type="l" tells plot you want to display the data as a line instead of as a<br>
| scatterplot.</p>
<blockquote>
<p>plot(myx,myy,type="l",ylim=c(-3,3))</p>
</blockquote>
<p><img src="../images/r0041200.png" alt="image" title="image"></p>
<p>| You got it!</p>
<p>|====================================================                          |  67%<br>
| Notice how plot plotted the points in the (-3,3) range for y-values. The outlier at<br>
| (50,100) is NOT shown on the line plot. Now we'll plot the same data with ggplot.<br>
| Recall that the name of the dataframe is testdat. Create the graphical object g with<br>
| a call to ggplot with 2 arguments, testdat (the data) and a call to aes with 2<br>
| arguments, x set equal to myx, and y set equal to myy.</p>
<blockquote>
<p>g&lt;-ggplot(data=testdat,aes(x=myx,y=myy))</p>
</blockquote>
<p>| You got it!</p>
<p>|======================================================                        |  69%<br>
| Now add a call to geom_line with 0 arguments to g.</p>
<blockquote>
<p>g+geom_line()</p>
</blockquote>
<p><img src="../images/r0041210.png" alt="image" title="image"></p>
<p>| You got it right!</p>
<p>|=======================================================                       |  71%<br>
| Notice how ggplot DID display the outlier point at (50,100). As a result the rest of<br>
| the data is smashed down so you don't get to see what the bulk of it looks like. The<br>
| single outlier probably isn't important enough to dominate the graph. How do we get<br>
| ggplot to behave more like plot in a situation like this?</p>
<p>...</p>
<p>|=========================================================                     |  73%<br>
| Let's take a guess that in addition to adding geom_line() to g we also just have to<br>
| add ylim(-3,3) to it as we did with the call to plot. Try this now to see what<br>
| happens.</p>
<blockquote>
<p>g+geom_line()+ylim(-3,3)</p>
</blockquote>
<p><img src="../images/r0041220.png" alt="image" title="image"></p>
<p>| Perseverance, that's the answer.</p>
<p>|==========================================================                    |  75%<br>
| Notice that by doing this, ggplot simply ignored the outlier point at (50,100).<br>
| There's a break in the line which isn't very noticeable. Now recall that at the<br>
| beginning of the lesson we mentioned 7 components of a ggplot plot, one of which was<br>
| a coordinate system. This is a situation where using a coordinate system would be<br>
| helpful. Instead of adding ylim(-3,3) to the expression g+geom_line(), add a call to<br>
| the function coord_cartesian with the argument ylim set equal to c(-3,3).</p>
<blockquote>
<p>g+geom_line()+coord_cartesian(ylim=c(-3,3))</p>
</blockquote>
<p><img src="../images/r0041230.png" alt="image" title="image"></p>
<p>| You are really on a roll!</p>
<p>|============================================================                  |  77%<br>
| See the difference? This looks more like the plot produced by the base plot function.<br>
| The outlier y value at x=50 is not shown, but the plot indicates that it is larger<br>
| than 3.</p>
<p>...</p>
<p>|==============================================================                |  79%<br>
| We'll close with a more complicated example to show you the full power of ggplot and<br>
| the entire ggplot2 package. We'll continue to work with the mpg dataset.</p>
<p>...</p>
<p>|===============================================================               |  81%<br>
| Start by creating the graphical object g by assigning to it a call to ggplot with 2<br>
| arguments. The first is the dataset and the second is a call to the function aes.<br>
| This call will have 3 arguments, x set equal to displ, y set equal to hwy, and color<br>
| set equal to factor(year). This last will allow us to distinguish between the two<br>
| manufacturing years (1999 and 2008) in our data.</p>
<blockquote>
<p>g&lt;-ggplot(data=mpg,aes(x=displ,y=hwy,color=factor(year)))</p>
</blockquote>
<p>| All that practice is paying off!</p>
<p>|=================================================================             |  83%<br>
| Uh oh! Nothing happened. Does g exist? Of course, it just isn't visible yet since you<br>
| didn't add a layer.</p>
<p>...</p>
<p>|===================================================================           |  85%<br>
| If you typed g at the command line, what would happen?</p>
<p>1: a scatterplot would appear with 2 colors of points<br>
2: I would have to try this to answer the question<br>
3: R would return an error in red</p>
<p>Selection: 3</p>
<p>| You got it!</p>
<p>|====================================================================          |  88%<br>
| We'll build the plot up step by step. First add to g a call to the function<br>
| geom_point with 0 arguments.</p>
<blockquote>
<p>g+geom_point()</p>
</blockquote>
<p><img src="../images/r0041240.png" alt="image" title="image"></p>
<p>| You nailed it! Good job!</p>
<p>|======================================================================        |  90%<br>
| A simple, yet comfortingly familiar scatterplot appears. Let's make our display a 2<br>
| dimensional multi-panel plot. Recall your last command (with the up arrow) and add to<br>
| it a call the function facet_grid. Give it 2 arguments. The first is the formula<br>
| drv~cyl, and the second is the argument margins set equal to TRUE. Try this now.</p>
<blockquote>
<p>g+geom_point()+facet_grid(drv~cyl,margins=TRUE)</p>
</blockquote>
<p><img src="../images/r0041250.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|========================================================================      |  92%<br>
| A 4 by 5 plot, huh? The margins argument tells ggplot to display the marginal totals<br>
| over each row and column, so instead of seeing 3 rows (the number of drv factors) and<br>
| 4 columns (the number of cyl factors) we see a 4 by 5 display. Note that the panel in<br>
| position (4,5) is a tiny version of the scatterplot of the entire dataset.</p>
<p>...</p>
<p>|=========================================================================     |  94%<br>
| Now add to your last command (or retype it if you like to type) a call to geom_smooth<br>
| with 4 arguments. These are method set to "lm", se set to FALSE, size set to 2, and<br>
| color set to "black".</p>
<blockquote>
<p>g+geom_point()+facet_grid(drv~cyl,margins=TRUE)+geom_smooth(method="lm",se=FALSE,size=2,color="black")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041260.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|===========================================================================   |  96%<br>
| Angry Birds? Finally, add to your last command (or retype it if you like to type) a<br>
| call to the function labs with 3 arguments. These are x set to "Displacement", y set<br>
| to "Highway Mileage", and title set to "Swirl Rules!".</p>
<blockquote>
<p>g+geom_point()+facet_grid(drv~cyl,margins=TRUE)+geom_smooth(method="lm",se=FALSE,size=2,color="black")+labs(x="Displacement",y="Highway Mileage",title="Swirl Rules!")<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041270.png" alt="image" title="image"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|============================================================================  |  98%<br>
| You could have done these labels with separate calls to labs but we thought you'd be<br>
| sick of this by now. Anyway, congrats! You've concluded part 2 of ggplot2. We hope<br>
| you got enough mileage out of the lesson. If you like ggplot2 you can do some extras<br>
| with the extra lesson.</p>
<p>...</p>
<p>|==============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| You got it right!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>g+geom_point()+facet_grid(drv~cyl,margins=TRUE)+geom_smooth(method="lm",se=FALSE,size=2,color="black")+labs(x="Displacement",y="Highway Mileage",title="Swirl Rules!")+theme(plot.title = element_text(hjust = 0.5))<br><code>geom_smooth()</code> using formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0041280.png" alt="image" title="image"></p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-08 21:23:15.085181 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00426/" class="u-url">GGPlot2 Part1</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00426/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-08T20:00:59+05:30" itemprop="datePublished" title="2020-05-08 20:00">2020-05-08 20:00</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00426/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00426_GGPlot2 Part1.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00426_GGPlot2 Part1.html";
var idcomments_post_url = "/posts/00426/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote>
<p>library(swirl)<br>
library(ggplot2)<br>
swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>
<p>1: Principles of Analytic Graphs   2: Exploratory Graphs<br>
 3: Graphics Devices in R           4: Plotting Systems<br>
 5: Base Plotting System            6: Lattice Plotting System<br>
 7: Working with Colors             8: GGPlot2 Part1<br>
 9: GGPlot2 Part2                  10: GGPlot2 Extras<br>
11: Hierarchical Clustering        12: K Means Clustering<br>
13: Dimension Reduction            14: Clustering Example<br>
15: CaseStudy</p>
<p>Selection: 8</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>|                                                                             |   0%</p>
<p>| GGPlot2_Part1. (Slides for this and other Data Science courses may be found at<br>
| github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use<br>
| them, they must be downloaded as a zip file and viewed locally. This lesson<br>
| corresponds to 04_ExploratoryAnalysis/ggplot2.)</p>
<p>...</p>
<p>|==                                                                           |   2%<br>
| In another lesson, we gave you an overview of the three plotting systems in R. In<br>
| this lesson we'll focus on the third and newest plotting system in R, ggplot2.  As<br>
| we did with the other two systems, we'll focus on creating graphics on the screen<br>
| device rather than another graphics device.</p>
<p>...</p>
<p>|====                                                                         |   5%<br>
| The ggplot2 package is an add-on package available from CRAN via install.packages().<br>
| (Don't worry, we've installed it for you already.) It is an implementation of The<br>
| Grammar of Graphics, an abstract concept (as well as book) authored and invented by<br>
| Leland Wilkinson and implemented by Hadley Wickham while he was a graduate student<br>
| at Iowa State. The web site <a href="http://ggplot2.org">http://ggplot2.org</a> provides complete documentation.</p>
<p>...</p>
<p>|======                                                                       |   7%<br>
| A grammar of graphics represents an abstraction of graphics, that is, a theory of<br>
| graphics which conceptualizes basic pieces from which you can build new graphics and<br>
| graphical objects. The goal of the grammar is to “Shorten the distance from mind to<br>
| page”. From Hadley Wickham's book we learn that</p>
<p>...</p>
<p>|========                                                                     |  10%<br>
| The ggplot2 package "is composed of a set of independent components that can be<br>
| composed in many different ways. ... you can create new graphics that are precisely<br>
| tailored for your problem." These components include aesthetics which are attributes<br>
| such as colour, shape, and size, and geometric objects or geoms such as points,<br>
| lines, and bars.</p>
<p>...</p>
<p>|=========                                                                    |  12%<br>
| Before we delve into details, let's review the other 2 plotting systems.</p>
<p>...</p>
<p>|===========                                                                  |  15%<br>
| Recall what you know about R's base plotting system. Which of the following does NOT<br>
| apply to it?</p>
<p>1: It is convenient and mirrors how we think of building plots and analyzing data<br>
2: Can easily go back once the plot has started (e.g., to adjust margins or correct a typo)<br>
3: Use annotation functions to add/modify (text, lines, points, axis)<br>
4: Start with plot (or similar) function</p>
<p>Selection: 2</p>
<p>| That's correct!</p>
<p>|=============                                                                |  17%<br>
| Recall what you know about R's lattice plotting system. Which of the following does<br>
| NOT apply to it?</p>
<p>1: Margins and spacing are set automatically because entire plot is specified at once<br>
2: Most useful for conditioning types of plots and putting many panels on one plot<br>
3: Can always add to the plot once it is created<br>
4: Plots are created with a single function call (xyplot, bwplot, etc.)</p>
<p>Selection: 3</p>
<p>| Excellent job!</p>
<p>|===============                                                              |  20%<br>
| If we told you that ggplot2 combines the best of base and lattice, that would mean<br>
| it ...?</p>
<p>1: Automatically deals with spacings, text, titles but also allows you to annotate<br>
2: Its default mode makes many choices for you (but you can customize!)<br>
3: All of the others<br>
4: Like lattice it allows for multipanels but more easily and intuitively</p>
<p>Selection: 3</p>
<p>| You are quite good my friend!</p>
<p>|=================                                                            |  22%<br>
| Yes, ggplot2 combines the best of base and lattice. It allows for multipanel<br>
| (conditioning) plots (as lattice does) but also post facto annotation (as base<br>
| does), so you can add titles and labels. It uses the low-level grid package (which<br>
| comes with R) to draw the graphics. As part of its grammar philosophy, ggplot2 plots<br>
| are composed of aesthetics (attributes such as size, shape, color) and geoms<br>
| (points, lines, and bars), the geometric objects you see on the plot.</p>
<p>...</p>
<p>|===================                                                          |  24%<br>
| The ggplot2 package has 2 workhorse functions. The more basic workhorse function is<br>
| qplot, (think quick plot), which works like the plot function in the base graphics<br>
| system. It can produce many types of plots (scatter, histograms, box and whisker)<br>
| while hiding tedious details from the user. Similar to lattice functions, it looks<br>
| for data in a data frame or parent environment.</p>
<p>...</p>
<p>|=====================                                                        |  27%<br>
| The more advanced workhorse function in the package is ggplot, which is more<br>
| flexible and can be customized for doing things qplot cannot do. In this lesson<br>
| we'll focus on qplot.</p>
<p>...</p>
<p>|=======================                                                      |  29%<br>
| We'll start by showing how easy and versatile qplot is. First, let's look at some<br>
| data which comes with the ggplot2 package. The mpg data frame contains fuel economy<br>
| data for 38 models of cars manufactured in 1999 and 2008. Run the R command str with<br>
| the argument mpg. This will give you an idea of what mpg contains.</p>
<blockquote>
<p>str(mpg)</p>

<pre><code>tibble [234 x 11] (S3: tbl_df/tbl/data.frame)  
 $ manufacturer: chr [1:234] "audi" "audi" "audi" "audi" ...  
 $ model       : chr [1:234] "a4" "a4" "a4" "a4" ...  
 $ displ       : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ...  
 $ year        : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ...  
 $ cyl         : int [1:234] 4 4 4 4 6 6 6 4 4 4 ...  
 $ trans       : chr [1:234] "auto(l5)" "manual(m5)" "manual(m6)" "auto(av)" ...  
 $ drv         : chr [1:234] "f" "f" "f" "f" ...  
 $ cty         : int [1:234] 18 21 20 21 16 18 18 18 16 20 ...  
 $ hwy         : int [1:234] 29 29 31 30 26 26 27 26 25 28 ...  
 $ fl          : chr [1:234] "p" "p" "p" "p" ...  
 $ class       : chr [1:234] "compact" "compact" "compact" "compact" ...</code></pre>
<p>| You are really on a roll!</p>
</blockquote>
<p>|========================                                                     |  32%<br>
| We see that there are 234 points in the dataset concerning 11 different<br>
| characteristics of the cars. Suppose we want to see if there's a correlation between<br>
| engine displacement (displ) and highway miles per gallon (hwy). As we did with the<br>
| plot function of the base system we could simply call qplot with 3 arguments, the<br>
| first two are the variables we want to examine and the third argument data is set<br>
| equal to the name of the dataset which contains them (in this case, mpg). Try this<br>
| now.</p>
<blockquote>
<p>qplot(displ,hwy,data=mpg)</p>
</blockquote>
<p><img src="../images/r0040960.png" alt="image" title="image"></p>
<p>| You are amazing!</p>
<p>|==========================                                                   |  34%<br>
| A nice scatterplot done simply, right? All the labels are provided. The first<br>
| argument is shown along the x-axis and the second along the y-axis. The negative<br>
| trend (increasing displacement and lower gas mileage) is pretty clear. Now suppose<br>
| we want to do the same plot but this time use different colors to distinguish<br>
| between the 3 factors (subsets) of different types of drive (drv) in the data<br>
| (front-wheel, rear-wheel, and 4-wheel). Again, qplot makes this very easy. We'll<br>
| just add what ggplot2 calls an aesthetic, a fourth argument, color, and set it equal<br>
| to drv. Try this now. (Use the up arrow key to save some typing.)</p>
<blockquote>
<p>qplot(displ,hwy,data=mpg,color=drv)</p>
</blockquote>
<p><img src="../images/r0040970.png" alt="image" title="image"></p>
<p>| All that hard work is paying off!</p>
<p>|============================                                                 |  37%<br>
| Pretty cool, right? See the legend to the right which qplot helpfully supplied? The<br>
| colors were automatically assigned by qplot so the legend decodes the colors for<br>
| you. Notice that qplot automatically used dots or points to indicate the data. These<br>
| points are geoms (geometric objects). We could have used a different aesthetic, for<br>
| instance shape instead of color, to distinguish between the drive types.</p>
<p>...</p>
<p>|==============================                                               |  39%<br>
| Now let's add a second geom to the default points. How about some smoothing function<br>
| to produce trend lines, one for each color? Just add a fifth argument, geom, and<br>
| using the R function c(), set it equal to the concatenation of the two strings<br>
| "point" and "smooth". The first refers to the data points and second to the trend<br>
| lines we want plotted. Try this now.</p>
<blockquote>
<p>qplot(displ,hwy,data=mpg,color=drv,geom=c("point","smooth"))<br><code>geom_smooth()</code> using method = 'loess' and formula 'y ~ x'</p>
</blockquote>
<p><img src="../images/r0040980.png" alt="image" title="image"></p>
<p>| That's correct!</p>
<p>|================================                                             |  41%<br>
| Notice the gray areas surrounding each trend lines. These indicate the 95%<br>
| confidence intervals for the lines.</p>
<p>...</p>
<p>|==================================                                           |  44%<br>
| Before we leave qplot's scatterplotting ability, call qplot again, this time with 3<br>
| arguments. The first is y set equal to hwy, the second is data set equal to mpg, and<br>
| the third is color set equal to drv. Try this now.</p>
<blockquote>
<p>qplot(y=hwy,data=mpg,color=drv)</p>
</blockquote>
<p><img src="../images/r0040990.png" alt="image" title="image"></p>
<p>| Great job!</p>
<p>|====================================                                         |  46%<br>
| What's this plot showing? We see the x-axis ranges from 0 to 250 and we remember<br>
| that we had 234 data points in our set, so we can infer that each point in the plot<br>
| represents one of the hwy values (indicated by the y-axis). We've created the vector<br>
| myhigh for you which contains the hwy data from the mpg dataset. Look at myhigh now.</p>
<blockquote>
<p>play()</p>
</blockquote>
<p>| Entering play mode. Experiment as you please, then type nxt() when you are ready to<br>
| resume the lesson.</p>
<blockquote>
<p>qplot(y=hwy,data=mpg)</p>
</blockquote>
<p><img src="../images/r0041000.png" alt="image" title="image"></p>
<blockquote>
<p>nxt()</p>
</blockquote>
<p>| Resuming lesson...</p>
<p>| What's this plot showing? We see the x-axis ranges from 0 to 250 and we remember<br>
| that we had 234 data points in our set, so we can infer that each point in the plot<br>
| represents one of the hwy values (indicated by the y-axis). We've created the vector<br>
| myhigh for you which contains the hwy data from the mpg dataset. Look at myhigh now.</p>
<blockquote>
<p>myhigh</p>

<pre><code>  [1] 29 29 31 30 26 26 27 26 25 28 27 25 25 25 25 24 25 23 20 15 20 17 17 26 23 26 25  
 [28] 24 19 14 15 17 27 30 26 29 26 24 24 22 22 24 24 17 22 21 23 23 19 18 17 17 19 19  
 [55] 12 17 15 17 17 12 17 16 18 15 16 12 17 17 16 12 15 16 17 15 17 17 18 17 19 17 19  
 [82] 19 17 17 17 16 16 17 15 17 26 25 26 24 21 22 23 22 20 33 32 32 29 32 34 36 36 29  
[109] 26 27 30 31 26 26 28 26 29 28 27 24 24 24 22 19 20 17 12 19 18 14 15 18 18 15 17  
[136] 16 18 17 19 19 17 29 27 31 32 27 26 26 25 25 17 17 20 18 26 26 27 28 25 25 24 27  
[163] 25 26 23 26 26 26 26 25 27 25 27 20 20 19 17 20 17 29 27 31 31 26 26 28 27 29 31  
[190] 31 26 26 27 30 33 35 37 35 15 18 20 20 22 17 19 18 20 29 26 29 29 24 44 29 26 29  
[217] 29 29 29 23 24 44 41 29 26 28 29 29 29 28 29 26 26 26</code></pre>
<p>| You got it!</p>
</blockquote>
<p>|======================================                                       |  49%<br>
| Comparing the values of myhigh with the plot, we see the first entries in the vector<br>
| (29, 29, 31, 30,...) correspond to the leftmost points in the the plot (in order),<br>
| and the last entries in myhigh (28, 29, 26, 26, 26) correspond to the rightmost<br>
| plotted points. So, specifying the y parameter only, without an x argument, plots<br>
| the values of the y argument in the order in which they occur in the data.</p>
<p>...</p>
<p>|=======================================                                      |  51%<br>
| The all-purpose qplot can also create box and whisker plots.  Call qplot now with 4<br>
| arguments. First specify the variable by which you'll split the data, in this case<br>
| drv, then specify the variable which you want to examine, in this case hwy. The<br>
| third argument is data (set equal to mpg), and the fourth, the geom, set equal to<br>
| the string "boxplot"</p>
<blockquote>
<p>qplot(drv,hwy,data=mpg,geom="boxplot")</p>
</blockquote>
<p><img src="../images/r0041010.png" alt="image" title="image"></p>
<p>| Your dedication is inspiring!</p>
<p>|=========================================                                    |  54%<br>
| We see 3 boxes, one for each drive. Now to impress you, call qplot with 5 arguments.<br>
| The first 4 are just as you used previously, (drv, hwy, data set equal to mpg, and<br>
| geom set equal to the string "boxplot"). Now add a fifth argument, color, equal to<br>
| manufacturer.</p>
<blockquote>
<p>qplot(drv,hwy,data=mpg,geom="boxplot",color=manufacturer)</p>
</blockquote>
<p><img src="../images/r0041020.png" alt="image" title="image"></p>
<p>| You are amazing!</p>
<p>|===========================================                                  |  56%<br>
| It's a little squished but we just wanted to illustrate qplot's capabilities. Notice<br>
| that there are still 3 regions of the plot (determined by the factor drv). Each is<br>
| subdivided into several boxes depicting different manufacturers.</p>
<p>...</p>
<p>|=============================================                                |  59%<br>
| Now, on to histograms. These display frequency counts for a single variable. Let's<br>
| start with an easy one. Call qplot with 3 arguments. First specify the variable for<br>
| which you want the frequency count, in this case hwy, then specify the data (set<br>
| equal to mpg), and finally, the aesthetic, fill, set equal to drv. Instead of a plain<br>
| old histogram, this will again use colors to distinguish the 3 different drive<br>
| factors.</p>
<blockquote>
<p>qplot(hwy,data=mpg,fill=drv)<br><code>stat_bin()</code> using <code>bins = 30</code>. Pick better value with <code>binwidth</code>.</p>
</blockquote>
<p><img src="../images/r0041030.png" alt="image" title="image"></p>
<p>| Your dedication is inspiring!</p>
<p>|===============================================                              |  61%<br>
| See how qplot consistently uses the colors. Red (if 4-wheel drv is in the bin) is at<br>
| the bottom of the bin, then green on top of it (if present), followed by blue (rear<br>
| wheel drv). The color lets us see right away that 4-wheel drive vehicles in this<br>
| dataset don't have gas mileages exceeding 30 miles per gallon.</p>
<p>...</p>
<p>|=================================================                            |  63%<br>
| It's cool that qplot can do this so easily, but some people may find this multi-color<br>
| histogram hard to interpret. Instead of using colors to distinguish between the drive<br>
| factors let's use facets or panels. (That's what lattice called them.) This just<br>
| means we'll split the data into 3 subsets (according to drive) and make 3 smaller<br>
| individual plots of each subset in one plot (and with one call to qplot).</p>
<p>...</p>
<p>|===================================================                          |  66%<br>
| Remember that with base plot we had to do each subplot individually. The lattice<br>
| system made plotting conditioning plots easier. Let's see how easy it is with qplot.</p>
<p>...</p>
<p>|=====================================================                        |  68%<br>
| We'll do two plots, a scatterplot and then a histogram, each with 3 facets. For the<br>
| scatterplot, call qplot with 4 arguments. The first two are displ and hwy and the<br>
| third is the argument data set equal to mpg. The fourth is the argument facets which<br>
| will be set equal to the expression . ~ drv which is ggplot2's shorthand for number<br>
| of rows (to the left of the ~) and number of columns (to the right of the ~). Here<br>
| the . indicates a single row and drv implies 3, since there are 3 distinct drive<br>
| factors. Try this now.</p>
<blockquote>
<p>qplot(displ,hwy,data=mpg,facets=.~drv)</p>
</blockquote>
<p><img src="../images/r0041040.png" alt="image" title="image"></p>
<p>| Nice work!</p>
<p>|======================================================                       |  71%<br>
| The result is a 1 by 3 array of plots. Note how each is labeled at the top with the<br>
| factor label (4,f, or r). This shows us more detailed information than the histogram.<br>
| We see the relationship between displacement and highway mileage for each of the 3<br>
| drive factors.</p>
<p>...</p>
<p>|========================================================                     |  73%<br>
| Now we'll do a histogram, again calling qplot with 4 arguments. This time, since we<br>
| need only one variable for a histogram, the first is hwy and the second is the<br>
| argument data set equal to mpg. The third is the argument facets which we'll set<br>
| equal to the expression drv ~ . . This will give us a different arrangement of the<br>
| facets. The fourth argument is binwidth. Set this equal to 2. Try this now.</p>
<blockquote>
<p>qplot(hwy,data=mpg,facets=drv~.,binwidth=2)</p>
</blockquote>
<p><img src="../images/r0041050.png" alt="image" title="image"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|==========================================================                   |  76%<br>
| The facets argument, drv ~ ., resulted in what arrangement of facets?</p>
<p>1: 2 by 2<br>
2: 1 by 3<br>
3: 3 by 1<br>
4: huh?</p>
<p>Selection: 3</p>
<p>| Nice work!</p>
<p>|============================================================                 |  78%<br>
| Pretty good, right? Not too difficult either. Let's review what we learned!</p>
<p>...</p>
<p>|==============================================================               |  80%<br>
| Which of the following is a basic workhorse function of ggplot2?</p>
<p>1: gplot<br>
2: scatterplot<br>
3: qplot<br>
4: xyplot<br>
5: hist</p>
<p>Selection: 3</p>
<p>| All that practice is paying off!</p>
<p>|================================================================             |  83%<br>
| Which types of plot does qplot plot?</p>
<p>1: scatterplots<br>
2: all of the others<br>
3: histograms<br>
4: box and whisker plots</p>
<p>Selection: 2</p>
<p>| Great job!</p>
<p>|==================================================================           |  85%<br>
| What does the gg in ggplot2 stand for?</p>
<p>1: goto graphics<br>
2: grammar of graphics<br>
3: good grief<br>
4: good graphics</p>
<p>Selection: 2</p>
<p>| Your dedication is inspiring!</p>
<p>|====================================================================         |  88%<br>
| True or False? The geom argument takes a string for a value.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| Nice work!</p>
<p>|=====================================================================        |  90%<br>
| True or False? The data argument takes a string for a value.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| You're the best!</p>
<p>|=======================================================================      |  93%<br>
| True or False? The binwidth argument takes a string for a value.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| Great job!</p>
<p>|=========================================================================    |  95%<br>
| True or False? The user must specify x- and y-axis labels when using qplot.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| All that practice is paying off!</p>
<p>|===========================================================================  |  98%<br>
| Congrats! You've finished plot 1 of ggplot2. In the next lesson the plot thickens.</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| That's a job well done!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-08 20:04:09.107833 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00425/" class="u-url">Working with Colors</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00425/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-08T19:00:30+05:30" itemprop="datePublished" title="2020-05-08 19:00">2020-05-08 19:00</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00425/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00425_Working with Colors.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00425_Working with Colors.html";
var idcomments_post_url = "/posts/00425/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 4.0.0 (2020-04-24) -- "Arbor Day"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>Natural language support but running in an English locale</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<blockquote>
<p>setwd("C:/Users/kk/Downloads/edu/DataScienceJHU/DataScienceWithR/04_Exploratory_Data_Analysis/workspace")<br>
library(ggplot2)<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>

<pre><code> 1: Principles of Analytic Graphs   2: Exploratory Graphs             
 3: Graphics Devices in R           4: Plotting Systems               
 5: Base Plotting System            6: Lattice Plotting System        
 7: Working with Colors             8: GGPlot2 Part1                  
 9: GGPlot2 Part2                  10: GGPlot2 Extras                 
11: Hierarchical Clustering        12: K Means Clustering             
13: Dimension Reduction            14: Clustering Example             
15: CaseStudy</code></pre>
<p>Selection: 7</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘jpeg’ loaded correctly!</p>
<p>| Package ‘RColorBrewer’ loaded correctly!</p>
<p>| Package ‘datasets’ loaded correctly!</p>
<p>|                                                                             |   0%</p>
<p>| Working_with_Colors. (Slides for this and other Data Science courses may be found at<br>
| github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use<br>
| them, they must be downloaded as a zip file and viewed locally. This lesson<br>
| corresponds to 04_ExploratoryAnalysis/Colors.)</p>
<p>...</p>
<p>|=                                                                            |   1%<br>
| This lesson is about using colors in R. It really supplements the lessons on<br>
| plotting with the base and lattice packages which contain functions that are able to<br>
| take the argument col. We'll discuss ways to set this argument more colorfully.</p>
<p>...</p>
<p>|==                                                                           |   3%<br>
| Of course, color choice is secondary to your data and how you analyze it, but<br>
| effectively using colors can enhance your plots and presentations, emphasizing the<br>
| important points you're trying to convey.</p>
<p>...</p>
<p>|===                                                                          |   4%<br>
| The motivation for this lesson is that the default color schemes for most plots in R<br>
| are not optimal. Fortunately there have been recent developments to improve the<br>
| handling and specification of colors in plots and graphs. We'll cover some functions<br>
| in R as well as in external packages that are very handy. If you know how to use<br>
| some of these then you'll have more options when you create your displays.</p>
<p>...</p>
<p>|====                                                                         |   6%<br>
| We'll begin with a motivating example - a typical R plot using 3 default colors.</p>
<p><img src="../images/r0040830.png" alt="image" title="image"></p>
<p>...</p>
<p>|======                                                                       |   7%<br>
| According to the plot, what is color 2?</p>
<p>1: Blue<br>
2: Empty black circles<br>
3: Red<br>
4: Green</p>
<p>Selection: 3</p>
<p>| Nice work!</p>
<p>|=======                                                                      |   9%<br>
| So these are the first 3 default values. If you were plotting and just specified<br>
| col=c(1:3) as one of your arguments, these are colors you'd get. Maybe you like<br>
| them, but they might not be the best choice for your application.</p>
<p>...</p>
<p>|========                                                                     |  10%<br>
| To show you some options, here's a display of two color palettes that come with the<br>
| grDevices package available to you. The left shows you some colors from the function<br>
| heat.colors. Here low values are represented in red and as the values increase the<br>
| colors move through yellow towards white. This is consistent with the physical<br>
| properties of fire. The right display is from the function topo.colors which uses<br>
| topographical colors ranging from blue (low values) towards brown (higher values).</p>
<p><img src="../images/r0040840.png" alt="image" title="image"></p>
<p>...</p>
<p>|=========                                                                    |  12%<br>
| So we'll first discuss some functions that the grDevices package offers. The<br>
| function colors() lists the names of 657 predefined colors you can use in any<br>
| plotting function.  These names are returned as strings. Run the R command sample<br>
| with colors() as its first argument and 10 as its second to give you an idea of the<br>
| choices you have.</p>
<blockquote>
<p>sample(colors(),10)<br>
 [1] "gray1"         "darkorchid2"   "blue3"         "darkorchid3"   "gray10"<br>
 [6] "firebrick1"    "magenta3"      "gray75"        "lemonchiffon4" "rosybrown3"</p>
</blockquote>
<p>| Great job!</p>
<p>|==========                                                                   |  13%<br>
| We see a lot of variety in the colors, some of which are names followed by numbers<br>
| indicating that there are multiple forms of that particular color.</p>
<p>...</p>
<p>|===========                                                                  |  14%<br>
| So you're free to use any of these 600+ colors listed by the colors function.<br>
| However, two additional functions from grDevices, colorRamp and colorRampPalette,<br>
| give you more options. Both of these take color names as arguments and use them as<br>
| "palettes", that is, these argument colors are blended in different proportions to<br>
| form new colors.</p>
<p>...</p>
<p>|============                                                                 |  16%<br>
| The first, colorRamp, takes a palette of colors (the arguments) and returns a<br>
| function that takes values between 0 and 1 as arguments. The 0 and 1 correspond to<br>
| the extremes of the color palette. Arguments between 0 and 1 return blends of these<br>
| extremes.</p>
<p>...</p>
<p>|=============                                                                |  17%<br>
| Let's see what this means. Assign to the variable pal the output of a call to<br>
| colorRamp with the single argument, c("red","blue").</p>
<blockquote>
<p>pal&lt;-colorRamp(c("red","blue"))</p>
</blockquote>
<p>| You are amazing!</p>
<p>|===============                                                              |  19%<br>
| We don't see any output, but R has created the function pal which we can call with a<br>
| single argument between 0 and 1. Call pal now with the argument 0.</p>
<blockquote>
<p>pal(0)<br>
     [,1] [,2] [,3]<br>
[1,]  255    0    0</p>
</blockquote>
<p>| You are quite good my friend!</p>
<p>|================                                                             |  20%<br>
| We see a 1 by 3 array with 255 as the first entry and 0 in the other 2. This 3 long<br>
| vector corresponds to red, green, blue (RGB) color encoding commonly used in<br>
| televisions and monitors. In R, 24 bits are used to represent colors. Think of these<br>
| 24 bits as 3 sets of 8 bits, each of which represents an intensity for one of the<br>
| colors red, green, and blue.</p>
<p>...</p>
<p>|=================                                                            |  22%<br>
| The 255 returned from the pal(0) call corresponds to the largest possible number<br>
| represented with 8 bits, so the vector (255,0,0) contains only red (no green or<br>
| blue), and moreover, it's the highest possible value of red.</p>
<p>...</p>
<p>|==================                                                           |  23%<br>
| Given that you created pal with the palette containing "red" and "blue", what color<br>
| do you think will be represented by the vector that pal(1) returns? Recall that pal<br>
| will only take arguments between 0 and 1, so 1 is the largest argument you can pass<br>
| it.</p>
<p>1: blue<br>
2: red<br>
3: green<br>
4: yellow</p>
<p>Selection: 1</p>
<p>| Keep up the great work!</p>
<p>|===================                                                          |  25%<br>
| Check your answer now by calling pal with the argument 1.</p>
<blockquote>
<p>pal(1)<br>
     [,1] [,2] [,3]<br>
[1,]    0    0  255</p>
</blockquote>
<p>| Excellent work!</p>
<p>|====================                                                         |  26%<br>
| You see the vector (0,0,255) which represents the highest intensity of blue. What<br>
| vector do you think the call pal(.5) will return?</p>
<p>1: (0,255,0)<br>
2: (255,255,255)<br>
3: (127.5,0,127.5)<br>
4: (255,0,255)</p>
<p>Selection: 3</p>
<p>| You got it!</p>
<p>|=====================                                                        |  28%<br>
| The function pal can take more than one argument. It returns one 3-long (or 4-long,<br>
| but more about this later) vector for each argument. To see this in action, call pal<br>
| with the argument seq(0,1,len=6).</p>
<blockquote>
<p>pal(seq(0,1,len=6))</p>

<pre><code>     [,1] [,2] [,3]  
[1,]  255    0    0  
[2,]  204    0   51  
[3,]  153    0  102  
[4,]  102    0  153  
[5,]   51    0  204  
[6,]    0    0  255</code></pre>
<p>| Nice work!</p>
</blockquote>
<p>|======================                                                       |  29%<br>
| Six vectors (each of length 3) are returned. The i-th vector is identical to output<br>
| that would be returned by the call pal(i/5) for i=0,...5. We see that the i-th row<br>
| (for i=1,...6) differs from the (i-1)-st row in the following way. Its red entry is<br>
| 51 = 255/5 points lower and its blue entry is 51 points higher.</p>
<p>...</p>
<p>|=======================                                                      |  30%<br>
| So pal creates colors using the palette we specified when we called colorRamp. In<br>
| this example none of pal's outputs will ever contain green since it wasn't in our<br>
| initial palette.</p>
<p>...</p>
<p>|=========================                                                    |  32%<br>
| We'll turn now to colorRampPalette, a function similar to colorRamp. It also takes a<br>
| palette of colors and returns a function. This function, however, takes integer<br>
| arguments (instead of numbers between 0 and 1) and returns a vector of colors each<br>
| of which is a blend of colors of the original palette.</p>
<p>...</p>
<p>|==========================                                                   |  33%<br>
| The argument you pass to the returned function specifies the number of colors you<br>
| want returned. Each element of the returned vector is a 24 bit number, represented<br>
| as 6 hexadecimal characters, which range from 0 to F. This set of 6 hex characters<br>
| represents the intensities of red, green, and blue, 2 characters for each color.</p>
<p>...</p>
<p>|===========================                                                  |  35%<br>
| To see this better, assign to the variable p1 the output of a call to<br>
| colorRampPalette with the single argument, c("red","blue"). We'll compare it to our<br>
| experiments using colorRamp.</p>
<blockquote>
<p>p1&lt;-colorRampPalette(c("red","blue"))</p>
</blockquote>
<p>| You got it!</p>
<p>|============================                                                 |  36%<br>
| Now call p1 with the argument 2.</p>
<blockquote>
<p>p1(2)<br>
[1] "#FF0000" "#0000FF"</p>
</blockquote>
<p>| All that hard work is paying off!</p>
<p>|=============================                                                |  38%<br>
| We see a 2-long vector is returned. The first entry FF0000 represents red. The FF is<br>
| hexadecimal for 255, the same value returned by our call pal(0). The second entry<br>
| 0000FF represents blue, also with intensity 255.</p>
<p>...</p>
<p>|==============================                                               |  39%<br>
| Now call p1 with the argument 6. Let's see if we get the same result as we did when<br>
| we called pal with the argument seq(0,1,len=6).</p>
<blockquote>
<p>p1(6)<br>
[1] "#FF0000" "#CC0033" "#990066" "#650099" "#3200CC" "#0000FF"</p>
</blockquote>
<p>| You are amazing!</p>
<p>|===============================                                              |  41%<br>
| Now we get the 6-long vector (FF0000, CC0033, 990066, 650099, 3200CC, 0000FF). We<br>
| see the two ends (FF0000 and 0000FF) are consistent with the colors red and blue.<br>
| How about CC0033? Type 0xcc or 0xCC at the command line to see the decimal<br>
| equivalent of this hex number. You must include the 0 before the x to specify that<br>
| you're entering a hexadecimal number.</p>
<blockquote>
<p>0xCC<br>
[1] 204</p>
</blockquote>
<p>| You are amazing!</p>
<p>|================================                                             |  42%<br>
| So 0xCC equals 204 and we can easily convert hex 33 to decimal, as in<br>
| 0x33=3*16+3=51. These were exactly the numbers we got in the second row returned<br>
| from our call to pal(seq(0,1,len=6)). We see that 4 of the 6 numbers agree with our<br>
| earlier call to pal. Two of the 6 differ slightly.</p>
<p>...</p>
<p>|=================================                                            |  43%<br>
| We can also form palettes using colors other than red, green and blue. Form a<br>
| palette, p2, by calling colorRampPalette with the colors "red" and "yellow".<br>
| Remember to concatenate them into a single argument.</p>
<blockquote>
<p>p2&lt;-colorRampPalette(c("red","yellow"))</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|===================================                                          |  45%<br>
| Now call p2 with the argument 2. This will show us the two extremes of the blends of<br>
| colors we'll get.</p>
<blockquote>
<p>p2(2)<br>
[1] "#FF0000" "#FFFF00"</p>
</blockquote>
<p>| Excellent work!</p>
<p>|====================================                                         |  46%<br>
| Not surprisingly the first color we see is FF0000, which we know represents red. The<br>
| second color returned, FFFF00, must represent yellow, a combination of full<br>
| intensity red and full intensity green. This makes sense, since yellow falls between<br>
| red and green on the color wheel as we see here. (We borrowed this image from<br>
| lucaskrech.com.)</p>
<p><img src="../images/r0040850.png" alt="image" title="image"></p>
<p>...</p>
<p>|=====================================                                        |  48%<br>
| Let's now call p2 with the argument 10. This will show us how the two extremes, red<br>
| and yellow, are blended together.</p>
<blockquote>
<p>p2(10)<br>
 [1] "#FF0000" "#FF1C00" "#FF3800" "#FF5500" "#FF7100" "#FF8D00" "#FFAA00" "#FFC600"<br>
 [9] "#FFE200" "#FFFF00"</p>
</blockquote>
<p>| Your dedication is inspiring!</p>
<p>|======================================                                       |  49%<br>
| So we see the 10-long vector. For each element, the red component is fixed at FF,<br>
| and the green component grows from 00 (at the first element) to FF (at the last).</p>
<p>...</p>
<p>|=======================================                                      |  51%<br>
| This is all fine and dandy but you're probably wondering when you can see how all<br>
| these colors show up in a display. We copied some code from the R documentation<br>
| pages (color.scale if you're interested) and created a function for you, showMe.<br>
| This takes as an argument, a color vector, which as you know, is precisely what<br>
| calls to p1 and p2 return to you. Call showMe now with p1(20).</p>
<blockquote>
<p>showMe(p1(20))</p>
</blockquote>
<p><img src="../images/r0040860.png" alt="image" title="image"></p>
<p>| That's the answer I was looking for.</p>
<p>|========================================                                     |  52%<br>
| We see the interpolated palette here. Low values in the lower left corner are red<br>
| and as you move to the upper right, the colors move toward blue. Now call showMe<br>
| with p2(20) as its argument.</p>
<blockquote>
<p>showMe(p2(20))</p>
</blockquote>
<p><img src="../images/r0040870.png" alt="image" title="image"></p>
<p>| You're the best!</p>
<p>|=========================================                                    |  54%<br>
| Here we see a similar display, the colors moving from red to yellow, the base colors<br>
| of our p2 palette. For fun, see what p2(2) looks like using showMe.</p>
<blockquote>
<p>showMe(p2(2))</p>
</blockquote>
<p><img src="../images/r0040880.png" alt="image" title="image"></p>
<p>| You are really on a roll!</p>
<p>|==========================================                                   |  55%<br>
| A much more basic pattern, simple but elegant.</p>
<p>...</p>
<p>|============================================                                 |  57%<br>
| We mentioned before that colorRamp (and colorRampPalette) could return a 3 or 4 long<br>
| vector of colors. We saw 3-long vectors returned indicating red, green, and blue<br>
| intensities. What would the 4th entry be?</p>
<p>...</p>
<p>|=============================================                                |  58%<br>
| We'll answer this indirectly. First, look at the function p1 that colorRampPalette<br>
| returned to you. Just type p1 at the command prompt.</p>
<blockquote>
<p>p1<br>
function (n)<br>
{<br>
    x &lt;- ramp(seq.int(0, 1, length.out = n))<br>
    if (ncol(x) == 4L)<br>
        rgb(x[, 1L], x[, 2L], x[, 3L], x[, 4L], maxColorValue = 255)<br>
    else rgb(x[, 1L], x[, 2L], x[, 3L], maxColorValue = 255)<br>
}</p>
<p>&lt;bytecode: 0x00000174e0c71940&gt;</p>
<p>&lt;environment: 0x00000174dbdd5a00&gt;</p>
</blockquote>
<p>| Keep up the great work!</p>
<p>|==============================================                               |  59%<br>
| We see that p1 is a short function with one argument, n. The argument n is used as<br>
| the length in a call to the function seq.int, itself an argument to the function<br>
| ramp. We can infer that ramp is just going to divide the interval from 0 to 1 into n<br>
| pieces.</p>
<p>...</p>
<p>|===============================================                              |  61%<br>
| The heart of p1 is really the call to the function rgb with either 4 or 5 arguments.<br>
| Use the ?fun construct to look at the R documentation for rgb now.</p>
<blockquote>
<p>?rgb</p>
</blockquote>
<p>| You got it!</p>
<p>|================================================                             |  62%<br>
| We see that rgb is a color specification function that can be used to produce any<br>
| color with red, green, blue proportions. We see the maxColorValue is 1 by default,<br>
| so if we called rgb with values for red, green and blue, we would specify numbers at<br>
| most 1 (assuming we didn't change the default for maxColorValue). According to the<br>
| documentation, what is the maximum number of arguments rgb can have?</p>
<p>1: 6<br>
2: 4<br>
3: 5<br>
4: 3</p>
<p>Selection: 1</p>
<p>| All that practice is paying off!</p>
<p>|=================================================                            |  64%<br>
| So the fourth argument is alpha which can be a logical, i.e., either TRUE or FALSE,<br>
| or a numerical value. Create the function p3 now by calling colorRampPalette with<br>
| the colors blue and green (remember to concatenate them into a single argument) and<br>
| setting the alpha argument to .5.</p>
<blockquote>
<p>p3&lt;-colorRampPalette(c("blue","green"),alpha=0.5)</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|==================================================                           |  65%<br>
| Now call p3 with the argument 5.</p>
<blockquote>
<p>p3(5)<br>
[1] "#0000FFFF" "#003FBFFF" "#007F7FFF" "#00BF3FFF" "#00FF00FF"</p>
</blockquote>
<p>| Perseverance, that's the answer.</p>
<p>|===================================================                          |  67%<br>
| We see that in the 5-long vector that the call returned, each element has 32 bits, 4<br>
| groups of 8 bits each. The last 8 bits represent the value of alpha. Since it was<br>
| NOT ZERO in the call to colorRampPalette, it gets the maximum FF value. (The same<br>
| result would happen if alpha had been set to TRUE.) When it was 0 or FALSE (as in<br>
| previous calls to colorRampPalette) it was given the value 00 and wasn't shown. The<br>
| leftmost 24 bits of each element are the same RGB encoding we previously saw.</p>
<p>...</p>
<p>|====================================================                         |  68%<br>
| So what is alpha? Alpha represents an opacity level, that is, how transparent should<br>
| the colors be. We can add color transparency with the alpha parameter to calls to<br>
| rgb. We haven't seen any examples of this yet, but we will now.</p>
<p>...</p>
<p>|======================================================                       |  70%<br>
| We generated 1000 random normal pairs for you in the variables x and y. We'll plot<br>
| them in a scatterplot by calling plot with 4 arguments. The variables x and y are<br>
| the first 2. The third is the print character argument pch. Set this equal to 19<br>
| (filled circles). The final argument is col which should be set equal to a call to<br>
| rgb. Give rgb 3 arguments, 0, .5, and .5.</p>
<blockquote>
<p>plot(x,y,pch=19,col=rgb(0,0.5,0.5))</p>
</blockquote>
<p><img src="../images/r0040890.png" alt="image" title="image"></p>
<p>| Your dedication is inspiring!</p>
<p>|=======================================================                      |  71%<br>
| Well this picture is okay for a scatterplot, a nice mix of blue and green, but it<br>
| really doesn't tell us too much information in the center portion, since the points<br>
| are so thick there. We see there are a lot of points, but is one area more filled<br>
| than another? We can't really discriminate between different point densities. This<br>
| is where the alpha argument can help us. Recall your plot command (use the up arrow)<br>
| and add a 4th argument, .3, to the call to rgb. This will be our value for alpha.</p>
<blockquote>
<p>plot(x,y,pch=19,col=rgb(0,0.5,0.5,0.3))</p>
</blockquote>
<p><img src="../images/r0040900.png" alt="image" title="image"></p>
<p>| You are amazing!</p>
<p>|========================================================                     |  72%<br>
| Clearly this is better. It shows us where, specifically, the densest areas of the<br>
| scatterplot really are.</p>
<p>...</p>
<p>|=========================================================                    |  74%<br>
| Our last topic for this lesson is the RColorBrewer Package, available on CRAN, that<br>
| contains interesting and useful color palettes, of which there are 3 types,<br>
| sequential, divergent, and qualitative. Which one you would choose to use depends on<br>
| your data.</p>
<p>...</p>
<p>|==========================================================                   |  75%<br>
| Here's a picture of the palettes available from this package. The top section shows<br>
| the sequential palettes in which the colors are ordered from light to dark. The<br>
| divergent palettes are at the bottom. Here the neutral color (white) is in the<br>
| center, and as you move from the middle to the two ends of each palette, the colors<br>
| increase in intensity. The middle display shows the qualitative palettes which look<br>
| like collections of random colors. These might be used to distinguish factors in<br>
| your data.</p>
<p><img src="../images/r0040910.png" alt="image" title="image"></p>
<p>...</p>
<p>|===========================================================                  |  77%<br>
| These colorBrewer palettes can be used in conjunction with the colorRamp() and<br>
| colorRampPalette() functions. You would use colors from a colorBrewer palette as<br>
| your base palette,i.e., as arguments to colorRamp or colorRampPalette which would<br>
| interpolate them to create new colors.</p>
<p>...</p>
<p>|============================================================                 |  78%<br>
| As an example of this, create a new object, cols by calling the function brewer.pal<br>
| with 2 arguments, 3 and "BuGn". The string "BuGn" is the second last palette in the<br>
| sequential display. The 3 tells the function how many different colors we want.</p>
<blockquote>
<p>cols&lt;-brewer.pal(3,"BuGn")</p>
</blockquote>
<p>| That's the answer I was looking for.</p>
<p>|=============================================================                |  80%<br>
| Use showMe to look at cols now.</p>
<blockquote>
<p>showMe(cols)</p>
</blockquote>
<p><img src="../images/r0040920.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|==============================================================               |  81%<br>
| We see 3 colors, mixes of blue and green. Now create the variable pal by calling<br>
| colorRampPalette with cols as its argument.</p>
<blockquote>
<p>pal&lt;-colorRampPalette(cols)</p>
</blockquote>
<p>| All that hard work is paying off!</p>
<p>|================================================================             |  83%<br>
| The call showMe(pal(3)) would be identical to the showMe(cols) call. So use showMe<br>
| to look at pal(20).</p>
<blockquote>
<p>showMe(pal(20))</p>
</blockquote>
<p><img src="../images/r0040930.png" alt="image" title="image"></p>
<p>| Keep up the great work!</p>
<p>|=================================================================            |  84%<br>
| Now we can use the colors in pal(20) to display topographic information on<br>
| Auckland's Maunga Whau Volcano. R provides this information in a matrix called<br>
| volcano which is included in the package datasets.  Call the R function image with<br>
| volcano as its first argument and col set equal to pal(20) as its second.</p>
<blockquote>
<p>image(volcano,col=pal(20))</p>
</blockquote>
<p><img src="../images/r0040940.png" alt="image" title="image"></p>
<p>| Great job!</p>
<p>|==================================================================           |  86%<br>
| We see that the colors here of the sequential palette clue us in on the topography.<br>
| The darker colors are more concentrated than the lighter ones. Just for fun, recall<br>
| your last command calling image and instead of pal(20), use p1(20) as the second<br>
| argument.</p>
<blockquote>
<p>image(volcano,col=p1(20))</p>
</blockquote>
<p><img src="../images/r0040950.png" alt="image" title="image"></p>
<p>| Your dedication is inspiring!</p>
<p>|===================================================================          |  87%<br>
| Not as nice a picture since the palette isn't as well suited to this data, but<br>
| that's okay. It's review time!!!!</p>
<p>...</p>
<p>|====================================================================         |  88%<br>
| True or False? Careful use of colors in plots/maps/etc. can make it easier for the<br>
| reader to understand what points you're trying to convey.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| You got it!</p>
<p>|=====================================================================        |  90%<br>
| Which of the following is an R package that provides color palettes for sequential,<br>
| categorical, and diverging data?</p>
<p>1: RColorBluer<br>
2: RColorBrewer<br>
3: RColorStewer<br>
4: RColorVintner</p>
<p>Selection: 2</p>
<p>| Keep working like that and you'll get there!</p>
<p>|======================================================================       |  91%<br>
| True or False? The colorRamp and colorRampPalette functions can be used in<br>
| conjunction with color palettes to connect data to colors.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| You are really on a roll!</p>
<p>|=======================================================================      |  93%<br>
| True or False?  Transparency can NEVER be used to clarify plots with many points</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| Excellent work!</p>
<p>|=========================================================================    |  94%<br>
| True or False?  The call p7 &lt;- colorRamp("red","blue") would work (i.e., not<br>
| generate an error).</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| Excellent job!</p>
<p>|==========================================================================   |  96%<br>
| True or False?  The function colors returns only 10 colors.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| All that practice is paying off!</p>
<p>|===========================================================================  |  97%<br>
| Transparency is determined by which parameter of the rgb function?</p>
<p>1: beta<br>
2: gamma<br>
3: it's all Greek to me<br>
4: delta<br>
5: alpha</p>
<p>Selection: 5</p>
<p>| You got it right!</p>
<p>|============================================================================ |  99%<br>
| Congratulations! We hope this lesson didn't make you see red. We're green with envy<br>
| that you blue through it.</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| Your dedication is inspiring!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-08 19:05:14.923558 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00424/" class="u-url">Lattice Plotting System</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00424/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-08T12:18:03+05:30" itemprop="datePublished" title="2020-05-08 12:18">2020-05-08 12:18</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00424/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00424_Lattice Plotting System.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00424_Lattice Plotting System.html";
var idcomments_post_url = "/posts/00424/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 4.0.0 (2020-04-24) -- "Arbor Day"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>Natural language support but running in an English locale</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<blockquote>
<p>setwd("C:/Users/kk/Downloads/edu/DataScienceJHU/DataScienceWithR/04_Exploratory_Data_Analysis/workspace")<br>
library(ggplot2)<br>
library(lattice)<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as<br>
| you did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>
<p>1: Principles of Analytic Graphs   2: Exploratory Graphs<br>
 3: Graphics Devices in R           4: Plotting Systems<br>
 5: Base Plotting System            6: Lattice Plotting System<br>
 7: Working with Colors             8: GGPlot2 Part1<br>
 9: GGPlot2 Part2                  10: GGPlot2 Extras<br>
11: Hierarchical Clustering        12: K Means Clustering<br>
13: Dimension Reduction            14: Clustering Example<br>
15: CaseStudy</p>
<p>Selection: 6</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘lattice’ loaded correctly!</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>|                                                                             |   0%</p>
<p>| Lattice_Plotting_System. (Slides for this and other Data Science courses may be<br>
| found at github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care<br>
| to use them, they must be downloaded as a zip file and viewed locally. This lesson<br>
| corresponds to 04_ExploratoryAnalysis/PlottingLattice.)</p>
<p>...</p>
<p>|=                                                                            |   1%<br>
| In another lesson, we gave you an overview of the three plotting systems in R. In<br>
| this lesson we'll focus on the lattice plotting system.  As we did with the base<br>
| plotting system, we'll focus on using lattice to create graphics on the screen<br>
| device rather than another graphics device.</p>
<p>...</p>
<p>|==                                                                           |   3%<br>
| The lattice plotting system is completely separate and independent of the base<br>
| plotting system. It's an add-on package so it has to be explicitly loaded with a<br>
| call to the R function library. We've done this for you. The R Documentation tells<br>
| us that lattice "is an implementation of Trellis graphics for R. It is a powerful<br>
| and elegant high-level data visualization system with an emphasis on multivariate<br>
| data."</p>
<p>...</p>
<p>|===                                                                          |   4%<br>
| Lattice is implemented using two packages. The first is called, not surprisingly,<br>
| lattice, and it contains code for producing Trellis graphics. Some of the functions<br>
| in this package are the higher level functions which you, the user, would call.<br>
| These include xyplot, bwplot, and levelplot.</p>
<p>...</p>
<p>|=====                                                                        |   6%<br>
| If xyplot produces a scatterplot, what kind of plot does bwplot produce?</p>
<p>1: box and whisker<br>
2: big and whittle<br>
3: bad and wonderful<br>
4: black and white</p>
<p>Selection: 1</p>
<p>| That's a job well done!</p>
<p>|======                                                                       |   7%<br>
| The second package in the lattice system is grid which contains the low-level<br>
| functions upon which the lattice package is built. You, the user, seldom call<br>
| functions from the grid package directly.</p>
<p>...</p>
<p>|=======                                                                      |   9%<br>
| Unlike base plotting, the lattice system does not have a "two-phase" aspect with<br>
| separate plotting and annotation. Instead all plotting and annotation is done at<br>
| once with a single function call.</p>
<p>...</p>
<p>|========                                                                     |  10%<br>
| The lattice system, as the base does, provides several different plotting functions.<br>
| These include xyplot for creating scatterplots, bwplot for box-and-whiskers plots or<br>
| boxplots, and histogram for histograms. There are several others (stripplot,<br>
| dotplot, splom and levelplot), which we won't cover here.</p>
<p>...</p>
<p>|=========                                                                    |  12%<br>
| Lattice functions generally take a formula for their first argument, usually of the<br>
| form y ~ x. This indicates that y depends on x, so in a scatterplot y would be<br>
| plotted on the y-axis and x on the x-axis.</p>
<p>...</p>
<p>|==========                                                                   |  13%<br>
| Here's an example of typical lattice plot call, xyplot(y ~ x | f <em> g, data). The f<br>
| and g represent the optional conditioning variables. The </em> represents interaction<br>
| between them. Remember when we said that lattice is good for plotting multivariate<br>
| data? That's where these conditioning variables come into play.</p>
<p>...</p>
<p>|===========                                                                  |  15%<br>
| The second argument is the data frame or list from which the variables in the<br>
| formula should be looked up.  If no data frame or list is passed, then the parent<br>
| frame is used. If no other arguments are passed, the default values are used.</p>
<p>...</p>
<p>|=============                                                                |  16%<br>
| Recall the airquality data we've used before. We've loaded it again for you. To<br>
| remind yourself what it looks like run the R command head with airquality as an<br>
| argument to see what the data looks like.</p>
<blockquote>
<p>head(airquality)</p>

<pre><code>  Ozone Solar.R Wind Temp Month Day  
1    41     190  7.4   67     5   1  
2    36     118  8.0   72     5   2  
3    12     149 12.6   74     5   3  
4    18     313 11.5   62     5   4  
5    NA      NA 14.3   56     5   5  
6    28      NA 14.9   66     5   6</code></pre>
<p>| You got it right!</p>
</blockquote>
<p>|==============                                                               |  18%<br>
| Now try running xyplot with the formula Ozone~Wind as the first argument and the<br>
| second argument data set equal to airquality.</p>
<blockquote>
<p>xyplot(Ozone~Wind,data=airquality)</p>
</blockquote>
<p><img src="../images/r0040730.png" alt="graph" title="graph"></p>
<p>| That's a job well done!</p>
<p>|===============                                                              |  19%<br>
| Look vaguely familiar? The dots are blue, instead of black, but lattice labeled the<br>
| axes for you. You can use some of the same graphical parameters (e.g., pch and col)<br>
| that you used in the base package in calls to lattice functions.</p>
<p>...</p>
<p>|================                                                             |  21%<br>
| Now rerun xyplot with the formula Ozone~Wind as the first argument and the second<br>
| argument data set equal to airquality (use the up arrow to save typing). This time<br>
| add the arguments col set equal to "red", pch set equal to 8, and main set equal to<br>
| "Big Apple Data".</p>
<blockquote>
<p>xyplot(Ozone ~ Wind, data = airquality, pch=8, col="red", main="Big Apple Data")</p>
</blockquote>
<p><img src="../images/r0040740.png" alt="graph" title="graph"></p>
<p>| You are really on a roll!</p>
<p>|=================                                                            |  22%<br>
| Red snowflakes are cool, right? Now that you’ve seen the basic xyplot() and some of<br>
| its arguments, you might want to experiment more by yourself when you're done with<br>
| the lesson to discover what other arguments and colors are available. (If you can't<br>
| wait to experiment, recall that swirl has play() and nxt() functions. At a command<br>
| prompt, typing play() allows you to leave swirl temporarily so you can try different<br>
| R commands at the console. Typing nxt() when you’re done playing brings you back to<br>
| swirl and you can resume your lesson.)</p>
<p>...</p>
<p>|==================                                                           |  24%<br>
| Now you'll see how easy it is to generate a multipanel plot using a single lattice<br>
| command.</p>
<p>...</p>
<p>|====================                                                         |  25%<br>
| Run xyplot with the formula Ozone~Wind | as.factor(Month) as the first argument and<br>
| the second argument data set equal to airquality (use the up arrow to save typing).<br>
| So far, not much is different, right? Add a third argument, layout, set equal to<br>
| c(5,1).</p>
<blockquote>
<p>xyplot(Ozone~Wind|as.factor(Month),data=airquality,layout=c(5,1))</p>
</blockquote>
<p><img src="../images/r0040750.png" alt="graph" title="graph"></p>
<p>| Great job!</p>
<p>|=====================                                                        |  27%<br>
| Note that the default color and plotting character are back. What did the<br>
| as.factor(Month) do?</p>
<p>1: Randomly divided the data into 5 panels<br>
2: Huh?<br>
3: Displayed and labeled each subplot with the month's integer<br>
4: Displayed the data by individual months</p>
<p>Selection: 3</p>
<p>| Perseverance, that's the answer.</p>
<p>|======================                                                       |  28%<br>
| Since Month is a named column of the airquality dataframe we had to tell R to treat<br>
| it as a factor. To see how this affects the plot, rerun the xyplot command you just<br>
| ran, but use Ozone ~ Wind | Month instead of Ozone ~ Wind | as.factor(Month) as the<br>
| first argument.</p>
<blockquote>
<p>xyplot(Ozone~Wind|Month,data=airquality,layout=c(5,1))</p>
</blockquote>
<p><img src="../images/r0040760.png" alt="graph" title="graph"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|=======================                                                      |  30%<br>
| Not as informative, right? The word Month in each panel really doesn't tell you much<br>
| if it doesn't identify which month it's plotting. Notice that the actual data is the<br>
| same between the two plots, though.</p>
<p>...</p>
<p>|========================                                                     |  31%<br>
| Lattice functions behave differently from base graphics functions in one critical<br>
| way. Recall that base graphics functions plot data directly to the graphics device<br>
| (e.g., screen, or file such as a PDF file). In contrast, lattice graphics functions<br>
| return an object of class trellis.</p>
<p>...</p>
<p>|=========================                                                    |  33%<br>
| The print methods for lattice functions actually do the work of plotting the data on<br>
| the graphics device. They return "plot objects" that can be stored (but it’s usually<br>
| better to just save the code and data). On the command line, trellis objects are<br>
| auto-printed so that it appears the function is plotting the data.</p>
<p>...</p>
<p>|==========================                                                   |  34%<br>
| To see this, create a variable p which is assigned the output of this simple call to<br>
| xyplot, xyplot(Ozone~Wind,data=airquality).</p>
<blockquote>
<p>p&lt;-xyplot(Ozone~Wind,data=airquality)</p>
</blockquote>
<p>| You are amazing!</p>
<p>|============================                                                 |  36%<br>
| Nothing plotted, right? But the object p is around.</p>
<p>...</p>
<p>|=============================                                                |  37%<br>
| Type p or print(p) now to see it.</p>
<blockquote>
<p>p</p>
</blockquote>
<p><img src="../images/r0040770.png" alt="graph" title="graph"></p>
<p>| Excellent job!</p>
<p>|==============================                                               |  39%<br>
| Like magic, it appears. Now run the R command names with p as its argument.</p>
<blockquote>
<p>names(p)<br>
 [1] "formula"           "as.table"          "aspect.fill"       "legend"<br>
 [5] "panel"             "page"              "layout"            "skip"<br>
 [9] "strip"             "strip.left"        "xscale.components" "yscale.components"<br>
[13] "axis"              "xlab"              "ylab"              "xlab.default"<br>
[17] "ylab.default"      "xlab.top"          "ylab.right"        "main"<br>
[21] "sub"               "x.between"         "y.between"         "par.settings"<br>
[25] "plot.args"         "lattice.options"   "par.strip.text"    "index.cond"<br>
[29] "perm.cond"         "condlevels"        "call"              "x.scales"<br>
[33] "y.scales"          "panel.args.common" "panel.args"        "packet.sizes"<br>
[37] "x.limits"          "y.limits"          "x.used.at"         "y.used.at"<br>
[41] "x.num.limit"       "y.num.limit"       "aspect.ratio"      "prepanel.default"<br>
[45] "prepanel"</p>
</blockquote>
<p>| All that practice is paying off!</p>
<p>|===============================                                              |  40%<br>
| We see that the trellis object p has 45 named properties, the first of which is<br>
| "formula" which isn't too surprising. A lot of these properties are probably NULL in<br>
| value. We've done some behind-the-scenes work for you and created two vectors. The<br>
| first, mynames, is a character vector of the names in p. The second is a boolean<br>
| vector, myfull, which has TRUE values for nonnull entries of p. Run mynames[myfull]<br>
| to see which entries of p are not NULL.</p>
<blockquote>
<p>mynames[myfull]<br>
 [1] "formula"           "as.table"          "aspect.fill"       "panel"<br>
 [5] "skip"              "strip"             "strip.left"        "xscale.components"<br>
 [9] "yscale.components" "axis"              "xlab"              "ylab"<br>
[13] "xlab.default"      "ylab.default"      "x.between"         "y.between"<br>
[17] "index.cond"        "perm.cond"         "condlevels"        "call"<br>
[21] "x.scales"          "y.scales"          "panel.args.common" "panel.args"<br>
[25] "packet.sizes"      "x.limits"          "y.limits"          "aspect.ratio"<br>
[29] "prepanel.default"</p>
</blockquote>
<p>| That's the answer I was looking for.</p>
<p>|================================                                             |  42%<br>
| Wow! 29 nonNull values for one little plot. Note that a lot of them are like the<br>
| ones we saw in the base plotting system. Let's look at the values of some of them.<br>
| Type p[["formula"]] now.</p>
<blockquote>
<p>p[["formula"]]<br>
Ozone ~ Wind</p>
</blockquote>
<p>| You are amazing!</p>
<p>|=================================                                            |  43%<br>
| Not surprising, is it? It's a familiar formula. Now look at p's x.limits. Remember<br>
| the double square brackets and quotes.</p>
<blockquote>
<p>p[["x.limits"]]<br>
[1]  0.37 22.03</p>
</blockquote>
<p>| Keep up the great work!</p>
<p>|==================================                                           |  45%<br>
| They match the plot, right? The x values are indeed between .37 and 22.03.</p>
<p>...</p>
<p>|====================================                                         |  46%<br>
| Again, not surprising. Before we wrap up, let's talk about lattice's panel functions<br>
| which control what happens inside each panel of the plot. The ease of making<br>
| multi-panel plots makes lattice very appealing. The lattice package comes with<br>
| default panel functions, but you can customize what happens in each panel.</p>
<p>...</p>
<p>|=====================================                                        |  48%<br>
| Panel functions receive the x and y coordinates of the data points in their panel<br>
| (along with any optional arguments). To see this, we've created some data for you -<br>
| two 100-long vectors, x and y. For its first 50 values y is a function of x, for the<br>
| last 50 values, y is random. We've also defined a 100-long factor vector f which<br>
| distinguishes between the first and last 50 elements of the two vectors. Run the R<br>
| command table with f as it argument.</p>
<blockquote>
<p>table(f)</p>

<pre><code>f  
Group 1 Group 2   
     50      50</code></pre>
<p>| That's a job well done!</p>
</blockquote>
<p>|======================================                                       |  49%<br>
| The first 50 entries of f are "Group 1" and the last 50 are "Group 2". Run xyplot<br>
| with two arguments. The first is the formula y~x|f, and the second is layout set<br>
| equal to c(2,1). Note that we're not providing an explicit data argument, so xyplot<br>
| will look in the environment and see the x and y that we've generated for you.</p>
<blockquote>
<p>xyplot(y~x|f,layout=c(2,1))</p>
</blockquote>
<p><img src="../images/r0040780.png" alt="graph" title="graph"></p>
<p>| You nailed it! Good job!</p>
<p>|=======================================                                      |  51%<br>
| To understand this a little better look at the variable v1 we've created for you.</p>
<blockquote>
<p>v1<br>
[1] -2.185287  1.101780 -2.716851  1.569850</p>
</blockquote>
<p>| You're the best!</p>
<p>|========================================                                     |  52%<br>
| The first two numbers are the range of the x values of Group 1 and the last two<br>
| numbers are the range of y values of Group 1. See how they match the values of the<br>
| left panel (Group 1) in the plot. Now look at v2 which holds the comparable numbers<br>
| for Group 2.</p>
<blockquote>
<p>v2<br>
[1] -1.6066772  2.2205197 -0.1605085  2.0341048</p>
</blockquote>
<p>| You nailed it! Good job!</p>
<p>|=========================================                                    |  54%<br>
| Again, the values match the plot. That's reassuring. We've copied some code from the<br>
| slides for you. To see it, type myedit("plot1.R"). This will open your editor and<br>
| display the R code in it.</p>
<blockquote>
<p>myedit("plot1.R")</p>
</blockquote>

<pre><code>p &lt;- xyplot(y ~ x | f, panel = function(x, y, ...) {  
  panel.xyplot(x, y, ...)  ## First call the default panel function for 'xyplot'  
  panel.abline(h = median(y), lty = 2)  ## Add a horizontal line at the median  
})  
print(p)  
invisible()</code></pre>
<p>| You are quite good my friend!</p>
<p>|===========================================                                  |  55%<br>
| How many calls to basic lattice plotting functions are there in plot1.R?</p>
<p>1: 1<br>
2: 2<br>
3: 3</p>
<p>Selection: 1</p>
<p>| You got it!</p>
<p>|============================================                                 |  57%<br>
| Note the panel function. How many formal arguments does it have?</p>
<p>1: 2<br>
2: 3<br>
3: 1</p>
<p>Selection: 1</p>
<p>| One more time. You can do it!</p>
<p>| You have to count the ... as an argument?</p>
<p>1: 1<br>
2: 3<br>
3: 2</p>
<p>Selection: 2</p>
<p>| Excellent job!</p>
<p>|=============================================                                |  58%<br>
| The panel function has 3 arguments, x, y and ... . This last stands for all other<br>
| arguments (such as graphical parameters) you might want to include. There are 2<br>
| lines in the panel function. Each invokes a panel method, the first to plot the data<br>
| in each panel (panel.xyplot), the second to draw a horizontal line in each panel<br>
| (panel.abline). Note the similarity of this last call to that of the base plotting<br>
| function of the same name.</p>
<p>...</p>
<p>|==============================================                               |  60%<br>
| We've defined a function for you, pathtofile, which takes a filename as its<br>
| argument. This makes sure R can find the file on your computer. Now run the R<br>
| command source with two arguments. The first is the call to pathtofile with the<br>
| string "plot1.R" as its argument and the second is the argument local set equal to<br>
| TRUE. This command will run the code contained in plot1.R within the swirl<br>
| environment so you can see what it does.</p>
<blockquote>
<p>source(pathtofile("plot1.R"),local=TRUE)</p>
</blockquote>
<p><img src="../images/r0040790.png" alt="graph" title="graph"></p>
<p>| That's the answer I was looking for.</p>
<p>|===============================================                              |  61%<br>
| See how the lines appear. The plot shows two panels because...?</p>
<p>1: there are 2 calls to panel methods<br>
2: f contains 2 factors<br>
3: there are 2 variables<br>
4: lattice can handle at most 2 panels</p>
<p>Selection: 2</p>
<p>| All that hard work is paying off!</p>
<p>|================================================                             |  63%<br>
| We've copied another piece of similar code, i.e., a call to xyplot with a custom<br>
| panel function, from the slides. To see it, type myedit("plot2.R"). This will open<br>
| your editor and display the R code in it.</p>
<blockquote>
<p>myedit("plot2.R")</p>
</blockquote>

<pre><code>p2 &lt;- xyplot(y ~ x | f, panel = function(x, y, ...) {  
  panel.xyplot(x, y, ...)  ## First call default panel function  
  panel.lmline(x, y, col = 2)  ## Overlay a simple linear regression line  
})  
print(p2)  
invisible()</code></pre>
<p>| You nailed it! Good job!</p>
<p>|=================================================                            |  64%<br>
| You can see how plot2.R differs from plot1.R, right?</p>
<p>...</p>
<p>|===================================================                          |  66%<br>
| Again, run the R command source with the two arguments pathtofile("plot2.R") and<br>
| local=TRUE. This will run the code in plot2.R.</p>
<blockquote>
<p>source(pathtofile("plot2.R"),local=TRUE)</p>
</blockquote>
<p><img src="../images/r0040800.png" alt="graph" title="graph"></p>
<p>| You are doing so well!</p>
<p>|====================================================                         |  67%<br>
| The regression lines are red because ...?</p>
<p>1: R always plots regression lines in red<br>
2: R is the first letter of the word red<br>
3: the custom panel function specified a col argument</p>
<p>Selection: 3</p>
<p>| Excellent job!</p>
<p>|=====================================================                        |  69%<br>
| Before we close we'll look at how easily lattice can handle a plot with a great many<br>
| panels. (The sky's the limit.) We've loaded some diamond data for you. It comes with<br>
| the ggplot2 package. We'll use it just to show off lattice's panel plotting<br>
| capability.</p>
<p>...</p>
<p>|======================================================                       |  70%<br>
| The data is in the data frame diamonds. Use the R command str to see what it looks<br>
| like.</p>
<blockquote>
<p>str(diamonds)</p>

<pre><code>tibble [53,940 x 10] (S3: tbl_df/tbl/data.frame)  
 $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...  
 $ cut    : Ord.factor w/ 5 levels "Fair"&lt;"Good"&lt;..: 5 4 2 4 2 3 3 3 1 3 ...  
 $ color  : Ord.factor w/ 7 levels "D"&lt;"E"&lt;"F"&lt;"G"&lt;..: 2 2 2 6 7 7 6 5 2 5 ...  
 $ clarity: Ord.factor w/ 8 levels "I1"&lt;"SI2"&lt;"SI1"&lt;..: 2 3 5 4 2 6 7 3 4 5 ...  
 $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...  
 $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...  
 $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...  
 $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...  
 $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...  
 $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...</code></pre>
<p>| Perseverance, that's the answer.</p>
</blockquote>
<p>|=======================================================                      |  72%<br>
| So the data frame contains 10 pieces of information for each of 53940 diamonds. Run<br>
| the R command table with diamonds$color as an argument.</p>
<blockquote>
<p>table(diamonds$color)</p>

<pre><code>    D     E     F     G     H     I     J   
 6775  9797  9542 11292  8304  5422  2808</code></pre>
<p>| You nailed it! Good job!</p>
</blockquote>
<p>|========================================================                     |  73%<br>
| We see 7 colors each represented by a letter. Now run the R command table with two<br>
| arguments, diamonds$color and diamonds$cut.</p>
<blockquote>
<p>table(diamonds$color,diamonds$cut)</p>

<pre><code>    Fair Good Very Good Premium Ideal  
  D  163  662      1513    1603  2834  
  E  224  933      2400    2337  3903  
  F  312  909      2164    2331  3826  
  G  314  871      2299    2924  4884  
  H  303  702      1824    2360  3115  
  I  175  522      1204    1428  2093  
  J  119  307       678     808   896</code></pre>
<p>| That's a job well done!</p>
</blockquote>
<p>|=========================================================                    |  75%<br>
| We see a 7 by 5 array with counts indicating how many diamonds in the data frame<br>
| have a particular color and cut. From the table, which is the most frequent<br>
| combination?</p>
<p>1: Ideal cut of color F.<br>
2: Ideal color of cut G<br>
3: Premium cut of color G<br>
4: Ideal cut of color G</p>
<p>Selection: 4</p>
<p>| Keep up the great work!</p>
<p>|===========================================================                  |  76%<br>
| To save you some trouble we've defined three character strings for you, labels for<br>
| the x- and y-axes and a main title. They're in the file myLabels.R, so run myedit on<br>
| this file to see them. Remember to put the file name in quotes when you call myedit.</p>
<blockquote>
<p>myedit("myLabels.R")</p>
</blockquote>

<pre><code>myxlab &lt;- "Carat"  
myylab &lt;- "Price"  
mymain &lt;- "Diamonds are Sparkly!"</code></pre>
<p>| Excellent job!</p>
<p>|============================================================                 |  78%<br>
| Now run source with pathtofile("myLabels.R") and local set equal to TRUE.</p>
<blockquote>
<p>source(pathtofile("myLabels.R"),local=TRUE)</p>
</blockquote>
<p>| All that hard work is paying off!</p>
<p>|=============================================================                |  79%<br>
| Now call xyplot with the formula price~carat | color*cut and data set equal to<br>
| diamonds. In addition, set the argument strip equal to FALSE, pch set equal to 20,<br>
| xlab to myxlab, ylab to myylab, and main to mymain. The plot may take longer than<br>
| previous plots because it is bigger.</p>
<blockquote>
<p>xyplot(price~carat|color*cut,data=diamonds,strip=FALSE,pch=20,xlab=myxlab,ylab=myylab,main=mymain)</p>
</blockquote>
<p><img src="../images/r0040810.png" alt="graph" title="graph"></p>
<p>| Excellent work!</p>
<p>|==============================================================               |  81%<br>
| Pretty cool, right? 35 panels, one for each combination of color and cut. The dots<br>
| (pch=20) show how prices for the diamonds in each category (panel) vary depending on<br>
| carat.</p>
<p>...</p>
<p>|===============================================================              |  82%<br>
| Are colors defining the rows or columns of the plot?</p>
<p>1: columns<br>
2: rows</p>
<p>Selection: 1</p>
<p>| You got it!</p>
<p>|================================================================             |  84%<br>
| Were you curious about that argument strip? I know I was. Now rerun the xyplot<br>
| command you just ran (use the up arrow key to retrieve it), this time without the<br>
| strip argument.</p>
<blockquote>
<p>xyplot(price~carat|color*cut,data=diamonds,pch=20,xlab=myxlab,ylab=myylab,main=mymain)</p>
</blockquote>
<p><img src="../images/r0040820.png" alt="graph" title="graph"></p>
<p>| All that hard work is paying off!</p>
<p>|==================================================================           |  85%<br>
| The plot shows that the strip argument ....</p>
<p>1: labels each panel<br>
2: removes information from the plot<br>
3: makes the plot less intelligible<br>
4: has a default value of FALSE</p>
<p>Selection: 1</p>
<p>| All that practice is paying off!</p>
<p>|===================================================================          |  87%<br>
| Review time!!!</p>
<p>...</p>
<p>|====================================================================         |  88%<br>
| True or False? Lattice plots are constructed by a series of calls to core functions.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| That's the answer I was looking for.</p>
<p>|=====================================================================        |  90%<br>
| True or False? Lattice plots are constructed with a single function call to a core<br>
| lattice function (e.g. xyplot)</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| You got it!</p>
<p>|======================================================================       |  91%<br>
| True or False? Aspects like margins and spacing are automatically handled and<br>
| defaults are usually sufficient.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| That's a job well done!</p>
<p>|=======================================================================      |  93%<br>
| True or False? The lattice system is ideal for creating conditioning plots where you<br>
| examine the same kind of plot under many different conditions.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 2</p>
<p>| Excellent job!</p>
<p>|========================================================================     |  94%<br>
| True or False? The lattice system, like the base plotting system, returns a trellis<br>
| plot object.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| Nice work!</p>
<p>|==========================================================================   |  96%<br>
| True or False?  Panel functions can NEVER be customized to modify what is plotted in<br>
| each of the plot panels.</p>
<p>1: True<br>
2: False</p>
<p>Selection: 2</p>
<p>| Your dedication is inspiring!</p>
<p>|===========================================================================  |  97%<br>
| True or False?  Lattice plots can display at most 20 panels in a single plot.</p>
<p>1: False<br>
2: True</p>
<p>Selection: 1</p>
<p>| You are doing so well!</p>
<p>|============================================================================ |  99%<br>
| Congrats! We hope this lesson didn't leave you climbing the trellis.</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: No<br>
2: Yes</p>
<p>Selection: 2<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| Keep up the great work!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-08 12:20:33.102850 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00423/" class="u-url">Base Plotting System</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00423/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-04T20:01:16+05:30" itemprop="datePublished" title="2020-05-04 20:01">2020-05-04 20:01</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00423/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00423_Base Plotting System.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00423_Base Plotting System.html";
var idcomments_post_url = "/posts/00423/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote>
<p>library(swirl)<br>
swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did<br>
| then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>
<p>1: Principles of Analytic Graphs   2: Exploratory Graphs<br>
 3: Graphics Devices in R           4: Plotting Systems<br>
 5: Base Plotting System            6: Lattice Plotting System<br>
 7: Working with Colors             8: GGPlot2 Part1<br>
 9: GGPlot2 Part2                  10: GGPlot2 Extras<br>
11: Hierarchical Clustering        12: K Means Clustering<br>
13: Dimension Reduction            14: Clustering Example<br>
15: CaseStudy</p>
<p>Selection: 5<br>
  |                                                                                   |   0%</p>
<p>| Base_Plotting_System. (Slides for this and other Data Science courses may be found at<br>
| github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use them,<br>
| they must be downloaded as a zip file and viewed locally. This lesson corresponds to<br>
| 04_ExploratoryAnalysis/PlottingBase.)</p>
<p>...</p>
<p>|=                                                                                  |   2%<br>
| In another lesson, we gave you an overview of the three plotting systems in R. In this<br>
| lesson we'll focus on the base plotting system and talk more about how you can exploit all<br>
| its many parameters to get the plot you want.  We'll focus on using the base plotting<br>
| system to create graphics on the screen device rather than another graphics device.</p>
<p>...</p>
<p>|===                                                                                |   3%<br>
| The core plotting and graphics engine in R is encapsulated in two packages. The first is<br>
| the graphics package which contains plotting functions for the "base" system. The<br>
| functions in this package include plot, hist, boxplot, barplot, etc. The second package is<br>
| grDevices which contains all the code implementing the various graphics devices, including<br>
| X11, PDF, PostScript, PNG, etc.</p>
<p>...</p>
<p>|====                                                                               |   5%<br>
| Base graphics are often constructed piecemeal, with each aspect of the plot handled<br>
| separately through a particular function call. Usually you start with a plot function<br>
| (such as plot, hist, or boxplot), then you use annotation functions (text, abline, points)<br>
| to add to or modify your plot.</p>
<p>...</p>
<p>|=====                                                                              |   6%<br>
| Before making a plot you have to determine where the plot will appear and what it will be<br>
| used for.  Is there a large amount of data going into the plot? Or is it just a few<br>
| points? Do you need to be able to dynamically resize the graphic?</p>
<p>...</p>
<p>|======                                                                             |   8%<br>
| What do you think is a disadvantage of the Base Plotting System?</p>
<p>1: It mirrors how we think of building plots and analyzing data<br>
2: You can't go back once a plot has started<br>
3: It's intuitive and exploratory<br>
4: A complicated plot is a series of simple R commands</p>
<p>Selection: 2</p>
<p>| That's a job well done!</p>
<p>|========                                                                           |   9%<br>
| Yes! The base system is very intuitive and easy to use. You can't go backwards, though,<br>
| say, if you need to readjust margins or have misspelled a caption. A finished plot will be<br>
| a series of R commands, so it's difficult to translate a finished plot into a different<br>
| system.</p>
<p>...</p>
<p>|=========                                                                          |  11%<br>
| Calling a basic routine such as plot(x, y) or hist(x) launches a graphics device (if one<br>
| is not already open) and draws a new plot on the device. If the arguments to plot or hist<br>
| are not of some special class, then the default method is called.</p>
<p>...</p>
<p>|==========                                                                         |  12%<br>
| As you'll see, most of the base plotting functions have many arguments, for example,<br>
| setting the title, labels of axes, plot character, etc. Some of the parameters can be set<br>
| when you call the function or they can be added later in a separate function call.</p>
<p>...</p>
<p>|===========                                                                        |  14%<br>
| Now we'll go through some quick examples of basic plotting before we delve into gory<br>
| details. We'll use the dataset airquality (part of the library datasets) which we've<br>
| loaded for you. This shows ozone and other air measurements for New York City for 5 months<br>
| in 1973.</p>
<p>...</p>
<p>|=============                                                                      |  15%<br>
| Use the R command head with airquality as an argument to see what the data looks like.</p>
<blockquote>
<p>head(airquality)<br>
  Ozone Solar.R Wind Temp Month Day<br>
1    41     190  7.4   67     5   1<br>
2    36     118  8.0   72     5   2<br>
3    12     149 12.6   74     5   3<br>
4    18     313 11.5   62     5   4<br>
5    NA      NA 14.3   56     5   5<br>
6    28      NA 14.9   66     5   6</p>
</blockquote>
<p>| Your dedication is inspiring!</p>
<p>|==============                                                                     |  17%<br>
| We see the dataset contains 6 columns of data. Run the command range with two arguments.<br>
| The first is the ozone column of airquality, specified by airquality\$Ozone, and the second<br>
| is the boolean na.rm set equal to TRUE. If you don't specify this second argument, you<br>
| won't get a meaningful result.</p>
<blockquote>
<p>range(airquality\$Ozone,na.rm=TRUE)<br>
[1]   1 168</p>
</blockquote>
<p>| Perseverance, that's the answer.</p>
<p>|===============                                                                    |  18%<br>
| So the measurements range from 1 to 168. First we'll do a simple histogram of this ozone<br>
| column to show the distribution of measurements. Use the R command hist with the argument<br>
| airquality\$Ozone.</p>
<blockquote>
<p>hist(airquality\$Ozone)</p>
</blockquote>
<p><img src="../images/r0040550.png" alt="graph" title="graph"></p>
<p>| You're the best!</p>
<p>|================                                                                   |  20%<br>
| Simple, right? R put a title on the histogram and labeled both axes for you. What is the<br>
| most frequent count?</p>
<p>1: Under 25<br>
2: Over 100<br>
3: Over 150<br>
4: Between 60 and 75</p>
<p>Selection: 1</p>
<p>| Great job!</p>
<p>|==================                                                                 |  21%<br>
| Next we'll do a boxplot. First, though, run the R command table with the argument<br>
| airquality\$Month.</p>
<blockquote>
<p>table(airquality\$Month)</p>
</blockquote>
<p>5  6  7  8  9<br>
31 30 31 31 30</p>
<p>| Excellent work!</p>
<p>|===================                                                                |  23%<br>
| We see that the data covers 5 months, May through September. We'll want a boxplot of ozone<br>
| as a function of the month in which the measurements were taken so we'll use the R formula<br>
| Ozone~Month as the first argument of boxplot. Our second argument will be airquality, the<br>
| dataset from which the variables of the first argument are taken.  Try this now.</p>
<blockquote>
<p>boxplot(Ozone~Month,airquality)</p>
</blockquote>
<p><img src="../images/r0040560.png" alt="graph" title="graph"></p>
<p>| Keep up the great work!</p>
<p>|====================                                                               |  24%<br>
| Note that boxplot, unlike hist, did NOT specify a title and axis labels for you<br>
| automatically.</p>
<p>...</p>
<p>|=====================                                                              |  26%<br>
| Let's call boxplot again to specify labels. (Use the up arrow to recover the previous<br>
| command and save yourself some typing.) We'll add more arguments to the call to specify<br>
| labels for the 2 axes. Set xlab equal to "Month" and ylab equal to "Ozone (ppb)". Specify<br>
| col.axis equal to "blue" and col.lab equal to "red". Try this now.</p>
<blockquote>
<p>boxplot(Ozone~Month,airquality,xlab="Month",ylab="Ozone (ppb)",col.axis="blue",col.lab="red")</p>
</blockquote>
<p><img src="../images/r0040570.png" alt="graph" title="graph"></p>
<p>| All that practice is paying off!</p>
<p>|=======================                                                            |  27%<br>
| Nice colors, but still no title. Let's add one with the R command title. Use the argument<br>
| main set equal to the string "Ozone and Wind in New York City".</p>
<blockquote>
<p>title(main="Ozone and Wind in New York City")</p>
</blockquote>
<p><img src="../images/r0040580.png" alt="graph" title="graph"></p>
<p>| Nice work!</p>
<p>|========================                                                           |  29%<br>
| Now we'll show you how to plot a simple two-dimensional scatterplot using the R function<br>
| plot. We'll show the relationship between Wind (x-axis) and Ozone (y-axis). We'll use the<br>
| function plot with those two arguments (Wind and Ozone, in that order). To save some<br>
| typing, though, we'll call the R command with using 2 arguments. The first argument of<br>
| with will be airquality, the dataset containing Wind and Ozone; the second argument will<br>
| be the call to plot. Doing this allows us to avoid using the longer notation, e.g.,<br>
| airquality\$Wind. Try this now.</p>
<blockquote>
<p>with(airquality,plot(Wind,Ozone))</p>
</blockquote>
<p><img src="../images/r0040590.png" alt="graph" title="graph"></p>
<p>| Perseverance, that's the answer.</p>
<p>|=========================                                                          |  30%<br>
| Note that plot generated labels for the x and y axes but no title.</p>
<p>...</p>
<p>|==========================                                                         |  32%<br>
| Add one now with the R command title. Use the argument main set equal to the string "Ozone<br>
| and Wind in New York City". (You can use the up arrow to recover the command if you don't<br>
| want to type it.)</p>
<blockquote>
<p>title(main="Ozone and Wind in New York City")</p>
</blockquote>
<p><img src="../images/r0040600.png" alt="graph" title="graph"></p>
<p>| Perseverance, that's the answer.</p>
<p>|============================                                                       |  33%<br>
| The basic plotting parameters are documented in the R help page for the function par. You<br>
| can use par to set parameters OR to find out what values are already set. To see just how<br>
| much flexibility you have, run the R command length with the argument par() now.</p>
<blockquote>
<p>length(par())<br>
[1] 72</p>
</blockquote>
<p>| All that hard work is paying off!</p>
<p>|=============================                                                      |  35%<br>
| So there are a boatload (72) of parameters that par() gives you access to. Run the R<br>
| function names with par() as its argument to see what these parameters are.</p>
<blockquote>
<p>names(par())<br>
 [1] "xlog"      "ylog"      "adj"       "ann"       "ask"       "bg"        "bty"<br>
 [8] "cex"       "cex.axis"  "cex.lab"   "cex.main"  "cex.sub"   "cin"       "col"<br>
[15] "col.axis"  "col.lab"   "col.main"  "col.sub"   "cra"       "crt"       "csi"<br>
[22] "cxy"       "din"       "err"       "family"    "fg"        "fig"       "fin"<br>
[29] "font"      "font.axis" "font.lab"  "font.main" "font.sub"  "lab"       "las"<br>
[36] "lend"      "lheight"   "ljoin"     "lmitre"    "lty"       "lwd"       "mai"<br>
[43] "mar"       "mex"       "mfcol"     "mfg"       "mfrow"     "mgp"       "mkh"<br>
[50] "new"       "oma"       "omd"       "omi"       "page"      "pch"       "pin"<br>
[57] "plt"       "ps"        "pty"       "smo"       "srt"       "tck"       "tcl"<br>
[64] "usr"       "xaxp"      "xaxs"      "xaxt"      "xpd"       "yaxp"      "yaxs"<br>
[71] "yaxt"      "ylbias"</p>
</blockquote>
<p>| You got it right!</p>
<p>|==============================                                                     |  36%<br>
| Variety is the spice of life. You might recognize some of these such as col and lwd from<br>
| previous swirl lessons. You can always run ?par to see what they do. For now, run the<br>
| command par()\$pin and see what you get.</p>
<blockquote>
<p>par()\$pin<br>
[1] 4.520417 1.805833</p>
</blockquote>
<p>| You got it!</p>
<p>|===============================                                                    |  38%<br>
| Alternatively, you could have gotten the same result by running par("pin") or par('pin')).<br>
| What do you think these two numbers represent?</p>
<p>1: Coordinates of the center of the plot window<br>
2: Random numbers<br>
3: A confidence interval<br>
4: Plot dimensions in inches</p>
<p>Selection: 4</p>
<p>| All that hard work is paying off!</p>
<p>|=================================                                                  |  39%<br>
| Now, run the command par("fg") or or par('fg') or par()\$fg and see what you get.</p>
<blockquote>
<p>par("fg")<br>
[1] "black"</p>
</blockquote>
<p>| You nailed it! Good job!</p>
<p>|==================================                                                 |  41%<br>
| It gave you a color, right? Since par()\$fg specifies foreground color, what do you think  
| par()\\$bg specifies?</p>
<p>1: Beautiful color<br>
2: blue-green<br>
3: Better color<br>
4: Background color</p>
<p>Selection: 4</p>
<p>| You are amazing!</p>
<p>|===================================                                                |  42%<br>
| Many base plotting functions share a set of parameters. We'll go through some of the more<br>
| commonly used ones now. See if you can tell what they do from their names.</p>
<p>...</p>
<p>|====================================                                               |  44%<br>
| What do you think the graphical parameter pch controls?</p>
<p>1: pc help<br>
2: plot character<br>
3: point control height<br>
4: picture characteristics</p>
<p>Selection: 2</p>
<p>| You are doing so well!</p>
<p>|===================================                                          |  45%<br>
| The plot character default is the open circle, but it "can either be a single<br>
| character or an integer code for one of a set of graphics symbols." Run the command<br>
| par("pch") to see the integer value of the default. When you need to, you can use<br>
| R's Documentation (?pch) to find what the other values mean.</p>
<blockquote>
<p>par("pch")<br>
[1] 1</p>
</blockquote>
<p>| You're the best!</p>
<p>|====================================                                         |  47%<br>
| So 1 is the code for the open circle. What do you think the graphical parameters lty<br>
| and lwd control respectively?</p>
<p>1: line length and width<br>
2: line slope and intercept<br>
3: line type and width<br>
4: line width and type</p>
<p>Selection: 3</p>
<p>| You nailed it! Good job!</p>
<p>|=====================================                                        |  48%<br>
| Run the command par("lty") to see the default line type.</p>
<blockquote>
<p>par("lty")<br>
[1] "solid"</p>
</blockquote>
<p>| Excellent job!</p>
<p>|======================================                                       |  50%<br>
| So the default line type is solid, but it can be dashed, dotted, etc. Once again,<br>
| R's ?par documentation will tell you what other line types are available. The line<br>
| width is a positive integer; the default value is 1.</p>
<p>...</p>
<p>|========================================                                     |  52%<br>
| We've seen a lot of examples of col, the plotting color, specified as a number,<br>
| string, or hex code; the colors() function gives you a vector of colors by name.</p>
<p>...</p>
<p>|=========================================                                    |  53%<br>
| What do you think the graphical parameters xlab and ylab control respectively?</p>
<p>1: labels for the y- and x- axes<br>
2: labels for the x- and y- axes</p>
<p>Selection: 2</p>
<p>| You are quite good my friend!</p>
<p>|==========================================                                   |  55%<br>
| The par() function is used to specify global graphics parameters that affect all<br>
| plots in an R session. (Use dev.off or plot.new to reset to the defaults.) These<br>
| parameters can be overridden when specified as arguments to specific plotting<br>
| functions. These include las (the orientation of the axis labels on the plot), bg<br>
| (background color), mar (margin size), oma (outer margin size), mfrow and mfcol<br>
| (number of plots per row, column).</p>
<p>...</p>
<p>|===========================================                                  |  56%<br>
| The last two, mfrow and mfcol, both deal with multiple plots in that they specify<br>
| the number of plots per row and column. The difference between them is the order in<br>
| which they fill the plot matrix. The call mfrow will fill the rows first while mfcol<br>
| fills the columns first.</p>
<p>...</p>
<p>|============================================                                 |  58%<br>
| So to reiterate, first call a basic plotting routine. For instance, plot makes a<br>
| scatterplot or other type of plot depending on the class of the object being<br>
| plotted.</p>
<p>...</p>
<p>|==============================================                               |  59%<br>
| As we've seen, R provides several annotating functions. Which of the following is<br>
| NOT one of them?</p>
<p>1: title<br>
2: hist<br>
3: lines<br>
4: text<br>
5: points</p>
<p>Selection: 2</p>
<p>| Your dedication is inspiring!</p>
<p>|===============================================                              |  61%<br>
| So you can add text, title, points, and lines to an existing plot. To add lines, you<br>
| give a vector of x values and a corresponding vector of y values (or a 2-column<br>
| matrix); the function lines just connects the dots. The function text adds text<br>
| labels to a plot using specified x, y coordinates.</p>
<p>...</p>
<p>|================================================                             |  62%<br>
| The function title adds annotations. These include x- and y- axis labels, title,<br>
| subtitle, and outer margin. Two other annotating functions are mtext which adds<br>
| arbitrary text to either the outer or inner margins of the plot and axis which adds<br>
| axis ticks and labels. Another useful function is legend which explains to the<br>
| reader what the symbols your plot uses mean.</p>
<p>...</p>
<p>|=================================================                            |  64%<br>
| Before we close, let's test your ability to make a somewhat complicated scatterplot.<br>
| First run plot with 3 arguments. airquality\$Wind, airquality\\$Ozone, and type set<br>
| equal to "n". This tells R to set up the plot but not to put the data in it.</p>
<blockquote>
<p>plot(airquality\$Wind,airquality\\$Ozone,type="n")<br>
There were 12 warnings (use warnings() to see them)</p>
</blockquote>
<p><img src="../images/r0040610.png" alt="graph" title="graph"></p>
<p>| You got it!</p>
<p>|==================================================                           |  65%<br>
| Now for the test. (You might need to check R's documentation for some of these.) Add<br>
| a title with the argument main set equal to the string "Wind and Ozone in NYC"</p>
<blockquote>
<p>title(main = "Wind and Ozone in NYC")</p>
</blockquote>
<p><img src="../images/r0040620.png" alt="graph" title="graph"></p>
<p>| That's the answer I was looking for.</p>
<p>|===================================================                          |  67%<br>
| Now create a variable called may by subsetting airquality appropriately. (Recall<br>
| that the data specifies months by number and May is the fifth month of the year.)</p>
<blockquote>
<p>may&lt;-subset(airquality,Month==5)</p>
</blockquote>
<p>| All that practice is paying off!</p>
<p>|=====================================================                        |  68%<br>
| Now use the R command points to plot May's wind and ozone (in that order) as solid<br>
| blue triangles. You have to set the color and plot character with two separate<br>
| arguments. Note we use points because we're adding to an existing plot.</p>
<blockquote>
<p>points(may\$Wind,may\\$Ozone,col="blue",pch=17)</p>
</blockquote>
<p><img src="../images/r0040630.png" alt="graph" title="graph"></p>
<p>| That's a job well done!</p>
<p>|======================================================                       |  70%<br>
| Now create the variable notmay by subsetting airquality appropriately.</p>
<blockquote>
<p>notmay&lt;-subset(airquality,Month!=5)</p>
</blockquote>
<p>| Keep up the great work!</p>
<p>|=======================================================                      |  71%<br>
| Now use the R command points to plot these notmay's wind and ozone (in that order)<br>
| as red snowflakes.</p>
<blockquote>
<p>points(notmay\$Wind,notmay\\$Ozone,col="red",pch=8)</p>
</blockquote>
<p><img src="../images/r0040640.png" alt="graph" title="graph"></p>
<p>| Your dedication is inspiring!</p>
<p>|========================================================                     |  73%<br>
| Now we'll use the R command legend to clarify the plot and explain what it means.<br>
| The function has a lot of arguments, but we'll only use 4. The first will be the<br>
| string "topright" to tell R where to put the legend. The remaining 3 arguments will<br>
| each be 2-long vectors created by R's concatenate function, e.g., c(). These<br>
| arguments are pch, col, and legend. The first is the vector (17,8), the second<br>
| ("blue","red"), and the third ("May","Other Months"). Try it now.</p>
<blockquote>
<p>legend("topright",pch=c(17,8),col=c("blue","red"),legend=c("May","Other Months"))</p>
</blockquote>
<p><img src="../images/r0040650.png" alt="graph" title="graph"></p>
<p>| That's a job well done!</p>
<p>|=========================================================                    |  74%<br>
| Now add a vertical line at the median of airquality\$Wind. Make it dashed (lty=2)<br>
| with a width of 2.</p>
<blockquote>
<p>abline(v=median(airquality\$Wind),lty=2,lwd=2)</p>
</blockquote>
<p><img src="../images/r0040660.png" alt="graph" title="graph"></p>
<p>| You are really on a roll!</p>
<p>|==========================================================                   |  76%<br>
| Use par with the parameter mfrow set equal to the vector (1,2) to set up the plot<br>
| window for two plots side by side. You won't see a result.</p>
<blockquote>
<p>par(mfrow=c(1,2))</p>
</blockquote>
<p>| You are doing so well!</p>
<p>|============================================================                 |  77%<br>
| Now plot airquality\$Wind and airquality\\$Ozone and use main to specify the title<br>
| "Ozone and Wind".</p>
<blockquote>
<p>plot(airquality\$Wind,airquality\\$Ozone,main="Ozone and Wind")</p>
</blockquote>
<p><img src="../images/r0040670.png" alt="graph" title="graph"></p>
<p>| Perseverance, that's the answer.</p>
<p>|=============================================================                |  79%<br>
| Now for the second plot.</p>
<p>...</p>
<p>|==============================================================               |  80%<br>
| Plot airquality\$Ozone and airquality\\$Solar.R and use main to specify the title<br>
| "Ozone and Solar Radiation".</p>
<blockquote>
<p>plot(airquality\$Ozone,airquality\\$Solar.R,main="Ozone and Solar Radiation")</p>
</blockquote>
<p><img src="../images/r0040680.png" alt="graph" title="graph"></p>
<p>| That's correct!</p>
<p>|===============================================================              |  82%<br>
| Now for something more challenging.</p>
<p>...</p>
<p>|================================================================             |  83%<br>
| This one with 3 plots, to illustrate inner and outer margins. First, set up the plot<br>
| window by typing par(mfrow = c(1, 3), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0))</p>
<blockquote>
<p>par(mfrow = c(1, 3), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0))</p>
</blockquote>
<p>| Perseverance, that's the answer.</p>
<p>|=================================================================            |  85%<br>
| Margins are specified as 4-long vectors of integers. Each number tells how many<br>
| lines of text to leave at each side. The numbers are assigned clockwise starting at<br>
| the bottom. The default for the inner margin is c(5.1, 4.1, 4.1, 2.1) so you can see<br>
| we reduced each of these so we'll have room for some outer text.</p>
<p>...</p>
<p>|==================================================================           |  86%<br>
| The first plot should be familiar. Plot airquality\$Wind and airquality\\$Ozone with<br>
| the title (argument main) as "Ozone and Wind".</p>
<blockquote>
<p>plot(airquality\$Wind,airquality\\$Ozone,main="Ozone and Wind")</p>
</blockquote>
<p><img src="../images/r0040690.png" alt="graph" title="graph"></p>
<p>| You nailed it! Good job!</p>
<p>|====================================================================         |  88%<br>
| The second plot is similar.</p>
<p>...</p>
<p>|=====================================================================        |  89%<br>
| Plot airquality\$Solar.R and airquality\\$Ozone with the title (argument main) as<br>
| "Ozone and Solar Radiation".</p>
<blockquote>
<p>plot(airquality\$Solar.R,airquality\\$Ozone,main="Ozone and Solar Radiation")</p>
</blockquote>
<p><img src="../images/r0040700.png" alt="graph" title="graph"></p>
<p>| That's a job well done!</p>
<p>|======================================================================       |  91%<br>
| Now for the final panel.</p>
<p>...</p>
<p>|=======================================================================      |  92%<br>
| Plot airquality\$Temp and airquality\\$Ozone with the title (argument main) as "Ozone<br>
| and Temperature".</p>
<blockquote>
<p>plot(airquality\$Temp,airquality\\$Ozone,main="Ozone and Temperature")</p>
</blockquote>
<p><img src="../images/r0040710.png" alt="graph" title="graph"></p>
<p>| You got it!</p>
<p>|========================================================================     |  94%<br>
| Now we'll put in a title.</p>
<p>...</p>
<p>|==========================================================================   |  95%<br>
| Since this is the main title, we specify it with the R command mtext. Call mtext<br>
| with the string "Ozone and Weather in New York City" and the argument outer set<br>
| equal to TRUE.</p>
<blockquote>
<p>mtext("Ozone and Weather in New York City",outer=TRUE)</p>
</blockquote>
<p><img src="../images/r0040720.png" alt="graph" title="graph"></p>
<p>| That's correct!</p>
<p>|===========================================================================  |  97%<br>
| Voila! Beautiful, right?</p>
<p>...</p>
<p>|============================================================================ |  98%<br>
| Congrats! You've weathered this lesson nicely and passed out of the No!zone.</p>
<p>...</p>
<p>|=============================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: No<br>
2: Yes</p>
<p>Selection: 2<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| All that practice is paying off!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-04 20:05:26.618647 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00422/" class="u-url">Plotting Systems</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00422/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-04T19:56:24+05:30" itemprop="datePublished" title="2020-05-04 19:56">2020-05-04 19:56</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00422/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00422_Plotting Systems.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00422_Plotting Systems.html";
var idcomments_post_url = "/posts/00422/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 4.0.0 (2020-04-24) -- "Arbor Day"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<blockquote>
<p>setwd("C:/Users/kk/PortableApps/Git/home/k-allika/repos/DataScienceWithR/04_Exploratory_Data_Analysis/week01/workspace")<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did<br>
| then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Would you like to continue with one of these lessons?</p>
<p>1: Exploratory Data Analysis Plotting Systems<br>
2: No. Let me start something new.</p>
<p>Selection: 1</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘ggplot2’ loaded correctly!</p>
<p>| Package ‘lattice’ loaded correctly!</p>
<p>| Package ‘jpeg’ loaded correctly!</p>
<p>| Plotting_Systems. (Slides for this and other Data Science courses may be found at github<br>
| <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use them, they must<br>
| be downloaded as a zip file and viewed locally. This lesson corresponds to<br>
| 04_ExploratoryAnalysis/PlottingSystems.)</p>
<p>...</p>
<p>|==                                                                                 |   3%<br>
| In this lesson, we'll give you a brief overview of the three plotting systems in R, their<br>
| differences, strengths, and weaknesses. We'll only cover the basics here to give you a<br>
| general idea of the systems and in later lessons we'll cover each system in more depth.</p>
<p>...</p>
<p>|====                                                                               |   5%<br>
| The first plotting system is the Base Plotting System which comes with R. It's the oldest<br>
| system which uses a simple "Artist's palette" model. What this means is that you start<br>
| with a blank canvas and build your plot up from there, step by step.</p>
<p>...</p>
<p>|=======                                                                            |   8%<br>
| Usually you start with a plot function (or something similar), then you use annotation<br>
| functions to add to or modify your plot. R provides many annotating functions such as<br>
| text, lines, points, and axis. R provides documentation for each of these. They all add to<br>
| an already existing plot.</p>
<p>...</p>
<p>|=========                                                                          |  11%<br>
| What do you think is a disadvantage of the Base Plotting System?</p>
<p>1: It mirrors how we think of building plots and analyzing data<br>
2: A complicated plot is a series of simple R commands<br>
3: You can't go back once a plot has started<br>
4: It's intuitive and exploratory</p>
<p>Selection: 3</p>
<p>| Nice work!</p>
<p>|===========                                                                        |  14%<br>
| Yes! The base system is very intuitive and easy to use when you're starting to do<br>
| exploratory graphing and looking for a research direction. You can't go backwards, though,<br>
| say, if you need to readjust margins or fix a misspelled a caption. A finished plot will<br>
| be a series of R commands, so it's difficult to translate a finished plot into a different<br>
| system.</p>
<p>...</p>
<p>|=============                                                                      |  16%<br>
| We've loaded the dataset cars for you to demonstrate how easy it is to plot. First, use<br>
| the R command head with cars as an argument to see what the data looks like.</p>
<blockquote>
<p>head(cars)<br>
  speed dist<br>
1     4    2<br>
2     4   10<br>
3     7    4<br>
4     7   22<br>
5     8   16<br>
6     9   10</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|================                                                                   |  19%<br>
| So the dataset collates the speeds and distances needed to stop for 50 cars. This data was<br>
| recorded in the 1920's.</p>
<p>...</p>
<p>|==================                                                                 |  22%<br>
| We'll use the R command with which takes two arguments. The first specifies a dataset or<br>
| environment in which to run the second argument, an R expression. This will save us a bit<br>
| of typing. Try running the command with now using cars as the first argument and a call to<br>
| plot as the second. The call to plot will take two arguments, speed and dist. Please<br>
| specify them in that order.</p>
<blockquote>
<p>with(cars,plot(speed,dist))</p>
</blockquote>
<p><img src="../images/r0040500.png" alt="graph" title="graph"></p>
<p>| You got it right!</p>
<p>|====================                                                               |  24%<br>
| Simple, right? You can see the relationship between the two variables, speed and distance.<br>
| The first variable is plotted along the x-axis and the second along the y-axis.</p>
<p>...</p>
<p>|======================                                                             |  27%<br>
| Now we'll show you what the function text does. Run the command text with three arguments.<br>
| The first two, x and y coordinates, specify the placement of the third argument, the text<br>
| to be added to the plot. Let the first argument be mean(cars\$speed), the second  
| max(cars\\$dist), and the third the string "SWIRL rules!". Try it now.</p>
<blockquote>
<p>text(mean(cars\$speed),max(cars\\$dist),"SWIRL rules!")</p>
</blockquote>
<p><img src="../images/r0040510.png" alt="graph" title="graph"></p>
<p>| You are quite good my friend!</p>
<p>|=========================                                                          |  30%<br>
| Ain't it the truth?</p>
<p>...</p>
<p>|===========================                                                        |  32%<br>
| Now we'll move on to the second plotting system, the Lattice System which comes in the<br>
| package of the same name. Unlike the Base System, lattice plots are created with a single<br>
| function call such as xyplot or bwplot. Margins and spacing are set automatically because<br>
| the entire plot is specified at once.</p>
<p>...</p>
<p>|=============================                                                      |  35%<br>
| The lattice system is most useful for conditioning types of plots which display how y<br>
| changes with x across levels of z. The variable z might be a categorical variable of your<br>
| data. This system is also good for putting many plots on a screen at once.</p>
<p>...</p>
<p>|===============================                                                    |  38%<br>
| The lattice system has several disadvantages. First, it is sometimes awkward to specify an<br>
| entire plot in a single function call. Annotating a plot may not be especially intuitive.<br>
| Second, using panel functions and subscripts is somewhat difficult and requires<br>
| preparation. Finally, you cannot "add" to the plot once it is created as you can with the<br>
| base system.</p>
<p>...</p>
<p>|==================================                                                 |  41%</p>
<p>| As before, we've loaded some data for you in the variable state. This data comes with the<br>
| lattice package and it concerns various characteristics of the 50 states in the U.S. Use<br>
| the R command head to see the first few entries of state now.</p>
<blockquote>
<p>head(state)<br>
           Population Income Illiteracy Life.Exp Murder HS.Grad Frost   Area region<br>
Alabama          3615   3624        2.1    69.05   15.1    41.3    20  50708  South<br>
Alaska            365   6315        1.5    69.31   11.3    66.7   152 566432   West<br>
Arizona          2212   4530        1.8    70.55    7.8    58.1    15 113417   West<br>
Arkansas         2110   3378        1.9    70.66   10.1    39.9    65  51945  South<br>
California      21198   5114        1.1    71.71   10.3    62.6    20 156361   West<br>
Colorado         2541   4884        0.7    72.06    6.8    63.9   166 103766   West</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|====================================                                               |  43%<br>
| As you can see state holds 9 pieces of information for each of the 50 states. The last<br>
| variable, region, specifies a category for each state. Run the R command table with the<br>
| argument state\$region to see how many categories there are and how many states are in<br>
| each.</p>
<blockquote>
<p>table(state\$region)</p>
</blockquote>

<pre><code>Northeast         South North Central          West   
        9            16            12            13   

</code></pre>
<p>| Your dedication is inspiring!</p>
<p>|======================================                                             |  46%<br>
| So there are 4 categories and the 50 states are sorted into them appropriately. Let's use<br>
| the lattice command xyplot to see how life expectancy varies with income in each of the<br>
| four regions.</p>
<p>...</p>
<p>|========================================                                           |  49%<br>
| To do this we'll give xyplot 3 arguments. The first is the most complicated. It is this R<br>
| formula, Life.Exp ~ Income | region, which indicates we're plotting life expectancy as it<br>
| depends on income for each region. The second argument, data, is set equal to state. This<br>
| allows us to use "Life.Exp" and "Income" in the formula instead of specifying the dataset<br>
| state for each term (as in state\$Income). The third argument, layout, is set equal to the<br>
| two-long vector c(4,1). Run xyplot now with these three arguments.</p>
<blockquote>
<p>xyplot(Life.Exp~Income|region,data=state,layout=c(4,1))</p>
</blockquote>
<p><img src="../images/r0040520.png" alt="graph" title="graph"></p>
<p>| Perseverance, that's the answer.</p>
<p>|===========================================                                        |  51%<br>
| We see the data for each of the 4 regions plotted in one row. Based on this plot, which<br>
| region of the U.S. seems to have the shortest life expectancy?</p>
<p>1: West<br>
2: South<br>
3: Northeast<br>
4: North Central</p>
<p>Selection: 2</p>
<p>| You got it!</p>
<p>|=============================================                                      |  54%<br>
| Just for fun rerun the xyplot and this time set layout to the vector c(2,2). To save<br>
| typing use the up arrow to recover the previous xyplot command.</p>
<blockquote>
<p>xyplot(Life.Exp~Income|region,data=state,layout=c(2,2))</p>
</blockquote>
<p><img src="../images/r0040530.png" alt="graph" title="graph"></p>
<p>| Your dedication is inspiring!</p>
<p>|===============================================                                    |  57%<br>
| See how the plot changed? No need for you to worry about margins or labels. The package<br>
| took care of all that for you.</p>
<p>...</p>
<p>|=================================================                                  |  59%<br>
| Now for the last plotting system, ggplot2, which is a hybrid of the base and lattice<br>
| systems. It automatically deals with spacing, text, titles (as Lattice does) but also<br>
| allows you to annotate by "adding" to a plot (as Base does), so it's the best of both<br>
| worlds.</p>
<p>...</p>
<p>|====================================================                               |  62%<br>
| Although ggplot2 bears a superficial similarity to lattice, it's generally easier and more<br>
| intuitive to use. Its default mode makes many choices for you but you can still customize<br>
| a lot. The package is based on a "grammar of graphics" (hence the gg in the name), so you<br>
| can control the aesthetics of your plots. For instance, you can plot conditioning graphs<br>
| and panel plots as we did in the lattice example.</p>
<p>...</p>
<p>|======================================================                             |  65%<br>
| We'll see an example now of ggplot2 with a simple (single) command. As before, we've<br>
| loaded a dataset for you from the ggplot2 package. This mpg data holds fuel economy data<br>
| between 1999 and 2008 for 38 different models of cars. Run head with mpg as an argument so<br>
| you get an idea of what the data looks like.</p>
<blockquote>
<p>head(mpg)<br>
# A tibble: 6 x 11<br>
  manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class<br><chr><chr><dbl><int><int><chr><chr><int><int><chr><chr><br>
1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compact<br>
2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compact<br>
3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compact<br>
4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compact<br>
5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compact<br>
6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compact</chr></chr></int></int></chr></chr></int></int></dbl></chr></chr></p>
</blockquote>
<p>| That's a job well done!</p>
<p>|========================================================                           |  68%<br>
| Looks complicated. Run dim with the argument mpg to see how big the dataset is.</p>
<blockquote>
<p>dim(mpg)<br>
[1] 234  11</p>
</blockquote>
<p>| Excellent work!</p>
<p>|==========================================================                         |  70%<br>
| Holy cow! That's a lot of information for just 38 models of cars. Run the R command table<br>
| with the argument mpg\$model. This will tell us how many models of cars we're dealing with.</p>
<blockquote>
<p>table(mpg\$model)</p>
</blockquote>

<pre><code>       4runner 4wd                     a4             a4 quattro             a6 quattro   
                 6                      7                      8                      3   
            altima     c1500 suburban 2wd                  camry           camry solara   
                 6                      5                      7                      7   
       caravan 2wd                  civic                corolla               corvette   
                11                      9                      5                      5   
 dakota pickup 4wd            durango 4wd         expedition 2wd           explorer 4wd   
                 9                      7                      3                      6   
   f150 pickup 4wd           forester awd     grand cherokee 4wd             grand prix   
                 7                      6                      8                      5   
               gti            impreza awd                  jetta        k1500 tahoe 4wd   
                 5                      8                      9                      4   
</code></pre>
<p>land cruiser wagon 4wd                 malibu                 maxima        mountaineer 4wd<br>
                     2                      5                      3                      4<br>
               mustang          navigator 2wd             new beetle                 passat<br>
                     9                      3                      6                      7<br>
        pathfinder 4wd    ram 1500 pickup 4wd            range rover                 sonata<br>
                     4                     10                      4                      7<br>
               tiburon      toyota tacoma 4wd<br>
                     7                      7</p>
<p>| Nice work!</p>
<p>|=============================================================                      |  73%<br>
| Oh, there are 38 models. We're interested in the effect engine displacement (displ) has on<br>
| highway gas mileage (hwy), so we'll use the ggplot2 command qplot to display this<br>
| relationship. Run qplot now with three arguments. The first two are the variables displ<br>
| and hwy we want to plot, and the third is the argument data set equal to mpg. As before,<br>
| this allows us to avoid using the mpg\$variable notation for the first two arguments.</p>
<blockquote>
<p>qplot(displ,hwy,data=mpg)</p>
</blockquote>
<p><img src="../images/r0040540.png" alt="graph" title="graph"></p>
<p>| You are doing so well!</p>
<p>|===============================================================                    |  76%<br>
| Not surprisingly we see that the bigger the engine displacement the lower the gas mileage.</p>
<p>...</p>
<p>|=================================================================                  |  78%<br>
| Let's review!</p>
<p>...</p>
<p>|===================================================================                |  81%<br>
| Which R plotting system is based on an artist's palette?</p>
<p>1: Winsor&amp;Newton<br>
2: ggplot2<br>
3: base<br>
4: lattice</p>
<p>Selection: 3</p>
<p>| All that practice is paying off!</p>
<p>|======================================================================             |  84%<br>
| Which R plotting system does NOT allow you to annotate plots with separate calls?</p>
<p>1: base<br>
2: ggplot2<br>
3: Winsor&amp;Newton<br>
4: lattice</p>
<p>Selection: 4</p>
<p>| You got it right!</p>
<p>|========================================================================           |  86%<br>
| Which R plotting system combines the best features of the other two?</p>
<p>1: base<br>
2: Winsor&amp;Newton<br>
3: lattice<br>
4: ggplot2</p>
<p>Selection: 4</p>
<p>| You are doing so well!</p>
<p>|==========================================================================         |  89%<br>
| Which R plotting system uses a graphics grammar?</p>
<p>1: lattice<br>
2: base<br>
3: Winsor&amp;Newton<br>
4: ggplot2</p>
<p>Selection: 4</p>
<p>| You're the best!</p>
<p>|============================================================================       |  92%<br>
| Which R plotting system forces you to make your entire plot with one call?</p>
<p>1: Winsor&amp;Newton<br>
2: lattice<br>
3: ggplot2<br>
4: base</p>
<p>Selection: 2</p>
<p>| You are amazing!</p>
<p>|===============================================================================    |  95%<br>
| Which of the following sells high quality artists' brushes?</p>
<p>1: Winsor&amp;Newton<br>
2: base<br>
3: ggplot2<br>
4: lattice</p>
<p>Selection: 1</p>
<p>| You nailed it! Good job!</p>
<p>|=================================================================================  |  97%<br>
| Congrats! You've concluded this plotting lesson. We hope you didn't find it plodding.</p>
<p>...</p>
<p>|===================================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| You nailed it! Good job!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-04 19:59:20.871482 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="00421/" class="u-url">Graphics Devices in R</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="00421/" rel="bookmark">
            <time class="published dt-published" datetime="2020-05-04T13:21:25+05:30" itemprop="datePublished" title="2020-05-04 13:21">2020-05-04 13:21</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00421/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00421_Graphics Devices in R.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00421_Graphics Devices in R.html";
var idcomments_post_url = "/posts/00421/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 4.0.0 (2020-04-24) -- "Arbor Day"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<blockquote>
<p>setwd("C:/Users/kk/PortableApps/Git/home/k-allika/repos/DataScienceWithR/04_Exploratory_Data_Analysis/week01/workspace")<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did<br>
| then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth Allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>
<p>1: Principles of Analytic Graphs   2: Exploratory Graphs<br>
 3: Graphics Devices in R           4: Plotting Systems<br>
 5: Base Plotting System            6: Lattice Plotting System<br>
 7: Working with Colors             8: GGPlot2 Part1<br>
 9: GGPlot2 Part2                  10: GGPlot2 Extras<br>
11: Hierarchical Clustering        12: K Means Clustering<br>
13: Dimension Reduction            14: Clustering Example<br>
15: CaseStudy</p>
<p>Selection: 3<br>
  |                                                                                   |   0%</p>
<p>| Graphics_Devices_in_R. (Slides for this and other Data Science courses may be found at<br>
| github <a href="https://github.com/DataScienceSpecialization/courses/">https://github.com/DataScienceSpecialization/courses/</a>. If you care to use them,<br>
| they must be downloaded as a zip file and viewed locally. This lesson corresponds to<br>
| 04_ExploratoryAnalysis/Graphics_Devices_in_R.)</p>
<p>...</p>
<p>|==                                                                                 |   3%<br>
| As the title suggests, this will be a short lesson introducing you to graphics devices in<br>
| R. So, what IS a graphics device?</p>
<p>...</p>
<p>|=====                                                                              |   6%<br>
| Would you believe that it is something where you can make a plot appear, either a screen<br>
| device, such as a window on your computer, OR a file device?</p>
<p>...</p>
<p>|=======                                                                            |   9%<br>
| There are several different kinds of file devices with particular characteristics and<br>
| hence uses. These include PDF, PNG, JPEG, SVG, and TIFF. We'll talk more about these<br>
| later.</p>
<p>...</p>
<p>|==========                                                                         |  12%<br>
| To be clear, when you make a plot in R, it has to be "sent" to a specific graphics device.<br>
| Usually this is the screen (the default device), especially when you're doing exploratory<br>
| work. You'll send your plots to files when you're ready to publish a report, make a<br>
| presentation, or send info to colleagues.</p>
<p>...</p>
<p>|============                                                                       |  15%<br>
| How you access your screen device depends on what computer system you're using. On a Mac<br>
| the screen device is launched with the call quartz(), on Windows you use the call<br>
| windows(), and on Unix/Linux x11().  On a given platform (Mac, Windows, Unix/Linux) there<br>
| is only one screen device, and obviously not all graphics devices are available on all<br>
| platforms (i.e. you cannot launch windows() on a Mac).</p>
<p>...</p>
<p>|===============                                                                    |  18%<br>
| Run the R command ?Devices to see what graphics devices are available on your system.</p>
<blockquote>
<p>?Devices</p>
</blockquote>
<p>| That's correct!</p>
<p>|=================                                                                  |  21%<br>
| R Documentation shows you what's available.</p>
<p>...</p>
<p>|====================                                                               |  24%<br>
| There are two basic approaches to plotting. The first, plotting to the screen, is the most<br>
| common. It's simple - you call a plotting function like plot, xyplot, or qplot (which you<br>
| call depends on the plotting system you favor, but that's another lesson), so that the<br>
| plot appears on the screen. Then you annotate (add to) the plot if necessary.</p>
<p>...</p>
<p>|======================                                                             |  26%<br>
| As an example, run the R command with with 2 arguments. The first is a dataset, faithful,<br>
| which comes with R, and the second is a call to the base plotting function plot. Your call<br>
| to plot should have two arguments, eruptions and waiting. Try this now to see what<br>
| happens.</p>
<blockquote>
<p>with(faithful,plot(eruptions,waiting))</p>
</blockquote>
<p><img src="../images/r0040470.png" alt="graph" title="graph"></p>
<p>| Excellent job!</p>
<p>|========================                                                           |  29%<br>
| See how R created a scatterplot on the screen for you? This shows that relationship<br>
| between eruptions of the geyser Old Faithful and waiting time. Now use the R function<br>
| title with the argument main set equal to the string "Old Faithful Geyser data". This is<br>
| an annotation to the plot.</p>
<blockquote>
<p>title(main="Old Faithful Geyser data")</p>
</blockquote>
<p><img src="../images/r0040480.png" alt="graph" title="graph"></p>
<p>| You are amazing!</p>
<p>|===========================                                                        |  32%<br>
| Simple, right?  Now run the command dev.cur(). This will show you the current plotting<br>
| device, the screen.</p>
<blockquote>
<p>dev.cur()<br>
RStudioGD<br>
        2</p>
</blockquote>
<p>| That's the answer I was looking for.</p>
<p>|=============================                                                      |  35%<br>
| The second way to create a plot is to send it to a file device. Depending on the type of<br>
| plot you're making, you explicitly launch a graphics device, e.g., a pdf file. Type the<br>
| command pdf(file="myplot.pdf") to launch the file device. This will create the pdf file<br>
| myplot.pdf in your working directory.</p>
<blockquote>
<p>pdf(file="myplot.pdf")</p>
</blockquote>
<p>| Nice work!</p>
<p>|================================                                                   |  38%<br>
| You then call the plotting function (if you are using a file device, no plot will appear<br>
| on the screen). Run the with command again to plot the Old Faithful data. Use the up arrow<br>
| key to recover the command and save yourself some typing.</p>
<blockquote>
<p>with(faithful,plot(eruptions,waiting))</p>
</blockquote>
<p>| That's correct!</p>
<p>|==================================                                                 |  41%<br>
| Now rerun the title command and annotate the plot. (Up arrow keys are great!)</p>
<blockquote>
<p>title(main="Old Faithful Geyser data")</p>
</blockquote>
<p>| You are doing so well!</p>
<p>|=====================================                                              |  44%<br>
| Finally, when plotting to a file device, you have to close the device with the command<br>
| dev.off(). This is very important! Don't do it yet, though. After closing, you'll be able<br>
| to view the pdf file on your computer.</p>
<p>...</p>
<p>|=======================================                                            |  47%<br>
| There are two basic types of file devices, vector and bitmap devices. These use different<br>
| formats and have different characteristics. Vector formats are good for line drawings and<br>
| plots with solid colors using a modest number of points, while bitmap formats are good for<br>
| plots with a large number of points, natural scenes or web-based plots.</p>
<p>...</p>
<p>|==========================================                                         |  50%<br>
| We'll mention 4 specific vector formats. The first is pdf, which we've just used in our<br>
| example. This is useful for line-type graphics and papers. It resizes well, is usually<br>
| portable, but it is not efficient if a plot has many objects/points.</p>
<p>...</p>
<p>|============================================                                       |  53%<br>
| The second is svg which is XML-based, scalable vector graphics. This supports animation<br>
| and interactivity and is potentially useful for web-based plots.</p>
<p>...</p>
<p>|==============================================                                     |  56%<br>
| The last two vector formats are win.metafile, a Windows-only metafile format, and<br>
| postscript (ps), an older format which also resizes well, is usually portable, and can be<br>
| used to create encapsulated postscript files. Unfortunately, Windows systems often don’t<br>
| have a postscript viewer.</p>
<p>...</p>
<p>|=================================================                                  |  59%<br>
| We'll also mention 4 different bitmap formats. The first is png (Portable Network<br>
| Graphics) which is good for line drawings or images with solid colors. It uses lossless<br>
| compression (like the old GIF format), and most web browsers can read this format<br>
| natively. In addition, png is good for plots with many points, but it does not resize<br>
| well.</p>
<p>...</p>
<p>|===================================================                                |  62%<br>
| In contrast, jpeg files are good for photographs or natural scenes. They use lossy<br>
| compression, so they're good for plots with many points. Files in jpeg format don't resize<br>
| well, but they can be read by almost any computer and any web browser. They're not great<br>
| for line drawings.</p>
<p>...</p>
<p>|======================================================                             |  65%<br>
| The last two bitmap formats are tiff, an older lossless compression meta-format and bmp<br>
| which is a native Windows bitmapped format.</p>
<p>...</p>
<p>|========================================================                           |  68%<br>
| Although it is possible to open multiple graphics devices (screen, file, or both), when<br>
| viewing multiple plots at once, plotting can only occur on one graphics device at a time.</p>
<p>...</p>
<p>|===========================================================                        |  71%<br>
| The currently active graphics device can be found by calling dev.cur(). Try it now to see<br>
| what number is assigned to your pdf device.</p>
<blockquote>
<p>dev.cur()<br>
pdf<br>
  4</p>
</blockquote>
<p>| Your dedication is inspiring!</p>
<p>|=============================================================                      |  74%<br>
| Now use dev.off() to close the device.</p>
<blockquote>
<p>dev.off()<br>
RStudioGD<br>
        2</p>
</blockquote>
<p>View <a href="../files/f0040010.pdf" title="myplot.pdf">myplot.pdf</a></p>
<p>| You are quite good my friend!</p>
<p>|===============================================================                    |  76%<br>
| Now rerun dev.cur() to see what integer your plotting window is assigned.</p>
<blockquote>
<p>dev.cur()<br>
RStudioGD<br>
        2</p>
</blockquote>
<p>| You got it!</p>
<p>|==================================================================                 |  79%<br>
| The device is back to what it was when you started. As you might have guessed, every open<br>
| graphics device is assigned an integer greater than or equal to 2. You can change the<br>
| active graphics device with dev.set(<integer>) where <integer> is the number associated<br>
| with the graphics device you want to switch to.</integer></integer></p>
<p>...</p>
<p>|====================================================================               |  82%<br>
| You can also copy a plot from one device to another. This can save you some time but<br>
| beware! Copying a plot is not an exact operation, so the result may not be identical to<br>
| the original. R provides some functions to help you do this. The function dev.copy copies<br>
| a plot from one device to another, and dev.copy2pdf specifically copies a plot to a PDF<br>
| file.</p>
<p>...</p>
<p>|=======================================================================            |  85%<br>
| Just for fun, rerun the with command again, with(faithful, plot(eruptions, waiting)), to<br>
| plot the Old Faithful data. Use the up arrow key to recover the command if you don't feel<br>
| like typing.</p>
<blockquote>
<p>with(faithful,plot(eruptions,waiting))</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|=========================================================================          |  88%<br>
| Now rerun the title command, title(main = "Old Faithful Geyser data"), to annotate the<br>
| plot. (Up arrow keys are great!)</p>
<blockquote>
<p>title(main="Old Faithful Geyser data")</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|============================================================================       |  91%<br>
| Now run dev.copy with the 2 arguments. The first is png, and the second is file set equal<br>
| to "geyserplot.png". This will copy your screen plot to a png file in your working<br>
| directory which you can view AFTER you close the device.</p>
<blockquote>
<p>dev.copy(png,"geyserplot.png")<br>
png<br>
  4</p>
</blockquote>
<p>| Not quite, but you're learning! Try again. Or, type info() for more options.</p>
<p>| Type dev.copy(png, file = "geyserplot.png") at the command prompt.</p>
<blockquote>
<p>dev.copy(png,file="geyserplot.png")<br>
png<br>
  5</p>
</blockquote>
<p>| That's correct!</p>
<p>|==============================================================================     |  94%<br>
| Don't forget to close the PNG device! Do it NOW!!! Then you'll be able to view the file.</p>
<blockquote>
<p>dev.off()<br>
RStudioGD<br>
        2</p>
</blockquote>
<p><img src="../images/r0040490.png" alt="geyserplot.png" title="geyserplot.png"></p>
<p>| Keep working like that and you'll get there!</p>
<p>|=================================================================================  |  97%<br>
| Congrats! We hope you found this lesson deviced well!</p>
<p>...</p>
<p>|===================================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| All that hard work is paying off!</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Exploratory Data Analysis<br>
2: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-05-04 13:23:19.344014 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    </article>
</div>

        <ul class="pager postindexpager clearfix">
<li class="next"><a href="index-3.html" rel="next">Older posts</a></li>
        </ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script><!--End of body content--><footer id="footer">
            Contents © 2020 Krishnakanth Allika 
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
            
            
        </footer>
</div>
</div>


        <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-163231811-1"></script><script>  window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-163231811-1'); gtag('set', {'user_id': 'USER_ID'});</script>
</body>
</html>
