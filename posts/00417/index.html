<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Grouping and Chaining with dplyr | Data Science with R</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://www.datascience.eu.org/posts/00417/">
<link rel="icon" href="../../files/favicon.ico" sizes="16x16">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Krishnakanth Allika">
<link rel="prev" href="../00416/" title="Manipulating Data with dplyr" type="text/html">
<link rel="next" href="../00418/" title="Tidying Data with tidyr" type="text/html">
<meta property="og:site_name" content="Data Science with R">
<meta property="og:title" content="Grouping and Chaining with dplyr">
<meta property="og:url" content="https://www.datascience.eu.org/posts/00417/">
<meta property="og:description" content='R version 3.6.3 (2020-02-29) -- "Holding the Windsock"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)
R is free software and comes with ABSOLUT'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-04-23T20:38:07+05:30">
<meta property="article:tag" content="chaining">
<meta property="article:tag" content="dplyr">
<meta property="article:tag" content="group_by">
<meta property="article:tag" content="piping">
<meta property="article:tag" content="quantile">
<meta property="article:tag" content="R">
<meta property="article:tag" content="swirl">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="https://www.datascience.eu.org/">

            <span id="blog-title">Data Science with R</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../toc/" class="nav-link">Table of Contents</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Categories</a>
                </li>
<li class="nav-item">
<a href="../../tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="https://www.datascience.eu.org" class="nav-link">Main site</a>

                
            </li>
</ul>
<!-- DuckDuckGo custom search --><form method="get" id="search" action="https://duckduckgo.com/" class="navbar-form pull-left">
<input type="hidden" name="sites" value="https://www.datascience.eu.org/"><input type="hidden" name="k8" value="#444444"><input type="hidden" name="k9" value="#D51920"><input type="hidden" name="kt" value="h"><input type="text" name="q" maxlength="255" placeholder="Search…" class="span2" style="margin-top: 4px;"><input type="submit" value="DuckDuckGo Search" style="visibility: hidden;">
</form>
<!-- End of custom search -->


            <ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Grouping and Chaining with dplyr</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Krishnakanth Allika
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2020-04-23T20:38:07+05:30" itemprop="datePublished" title="2020-04-23 20:38">2020-04-23 20:38</time></a>
            </p>
                <p class="commentline">
        
<a href="%7Blink%7D" onclick="this.href='/posts/00417/'; this.target='_self';"><span class="IDCommentsReplace" style="display:none">cache/posts/00417_Grouping and Chaining with dplyr.html</span>
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00417_Grouping and Chaining with dplyr.html";
var idcomments_post_url = "/posts/00417/";
</script><script src="https://www.intensedebate.com/js/genericLinkWrapperV2.js"></script></a>


            

        </p>
</div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>R version 3.6.3 (2020-02-29) -- "Holding the Windsock"<br>
Copyright (C) 2020 The R Foundation for Statistical Computing<br>
Platform: x86_64-w64-mingw32/x64 (64-bit)</p>
<p>R is free software and comes with ABSOLUTELY NO WARRANTY.<br>
You are welcome to redistribute it under certain conditions.<br>
Type 'license()' or 'licence()' for distribution details.</p>
<p>R is a collaborative project with many contributors.<br>
Type 'contributors()' for more information and<br>
'citation()' on how to cite R or R packages in publications.</p>
<p>Type 'demo()' for some demos, 'help()' for on-line help, or<br>
'help.start()' for an HTML browser interface to help.<br>
Type 'q()' to quit R.</p>
<p>[Workspace loaded from C:/Users/kk/PortableApps/Git/home/k-allika/repos/DataScienceWithR/.RData]</p>
<blockquote>
<p>setwd("C:/Users/kk/PortableApps/Git/home/k-allika/repos/DataScienceWithR/03_Getting_and_Cleaning_Data/Week03/workspace")<br>
library(swirl)</p>
</blockquote>
<p>| Hi! Type swirl() when you are ready to begin.</p>
<blockquote>
<p>swirl()</p>
</blockquote>
<p>| Welcome to swirl! Please sign in. If you've been here before, use the same name as you<br>
| did then. If you are new, call yourself something unique.</p>
<p>What shall I call you? Krishnakanth allika</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Getting and Cleaning Data<br>
2: R Programming<br>
3: Take me to the swirl course repository!</p>
<p>Selection: 1</p>
<p>| Please choose a lesson, or type 0 to return to course menu.</p>
<p>1: Manipulating Data with dplyr<br>
2: Grouping and Chaining with dplyr<br>
3: Tidying Data with tidyr<br>
4: Dates and Times with lubridate</p>
<p>Selection: 2</p>
<p>| Attempting to load lesson dependencies...</p>
<p>| Package ‘dplyr’ loaded correctly!</p>
<p>|                                                                                |   0%</p>
<p>| Warning: This lesson makes use of the View() function. View() may not work properly in<br>
| every programming environment. We highly recommend the use of RStudio for this lesson.</p>
<p>...</p>
<p>|==                                                                              |   2%<br>
| In the last lesson, you learned about the five main data manipulation 'verbs' in dplyr:<br>
| select(), filter(), arrange(), mutate(), and summarize(). The last of these,<br>
| summarize(), is most powerful when applied to grouped data.</p>
<p>...</p>
<p>|===                                                                             |   4%<br>
| The main idea behind grouping data is that you want to break up your dataset into<br>
| groups of rows based on the values of one or more variables. The group_by() function is<br>
| reponsible for doing this.</p>
<p>...</p>
<p>|=====                                                                           |   6%<br>
| We'll continue where we left off with RStudio's CRAN download log from July 8, 2014,<br>
| which contains information on roughly 225,000 R package downloads<br>
| (<a href="http://cran-logs.rstudio.com/">http://cran-logs.rstudio.com/</a>).</p>
<p>...</p>
<p>|======                                                                          |   8%<br>
| As with the last lesson, the dplyr package was automatically installed (if necessary)<br>
| and loaded at the beginning of this lesson. Normally, this is something you would have<br>
| to do on your own. Just to build the habit, type library(dplyr) now to load the package<br>
| again.</p>
<blockquote>
<p>library(dplyr)</p>
</blockquote>
<p>| That's the answer I was looking for.</p>
<p>|========                                                                        |  10%<br>
| I've made the dataset available to you in a data frame called mydf. Put it in a 'data<br>
| frame tbl' using the tbl_df() function and store the result in a object called cran. If<br>
| you're not sure what I'm talking about, you should start with the previous lesson.<br>
| Otherwise, practice makes perfect!</p>
<blockquote>
<p>cran&lt;-as_tibble(mydf)</p>
</blockquote>
<p>| Not exactly. Give it another go. Or, type info() for more options.</p>
<p>| Type cran &lt;- tbl_df(mydf) to store the data in a new tbl_df called cran.</p>
<blockquote>
<p>cran&lt;-tbl_df(mydf)</p>
</blockquote>
<p>| You are doing so well!</p>
<p>|=========                                                                       |  12%<br>
| To avoid confusion and keep things running smoothly, let's remove the original<br>
| dataframe from your workspace with rm("mydf").</p>
<blockquote>
<p>rm("mydf")</p>
</blockquote>
<p>| All that hard work is paying off!</p>
<p>|===========                                                                     |  13%<br>
| Print cran to the console.</p>
<blockquote>
<p>cran<br>
# A tibble: 225,468 x 11<br>
       X date     time       size r_version r_arch r_os    package   version country ip_id<br><int><chr><chr><int><chr><chr><chr><chr><chr><chr><int><br>
 1     1 2014-07~ 00:54:~   80589 3.1.0     x86_64 mingw32 htmltools 0.2.4   US          1<br>
 2     2 2014-07~ 00:59:~  321767 3.1.0     x86_64 mingw32 tseries   0.10-32 US          2<br>
 3     3 2014-07~ 00:47:~  748063 3.1.0     x86_64 linux-~ party     1.0-15  US          3<br>
 4     4 2014-07~ 00:48:~  606104 3.1.0     x86_64 linux-~ Hmisc     3.14-4  US          3<br>
 5     5 2014-07~ 00:46:~   79825 3.0.2     x86_64 linux-~ digest    0.6.4   CA          4<br>
 6     6 2014-07~ 00:48:~   77681 3.1.0     x86_64 linux-~ randomFo~ 4.6-7   US          3<br>
 7     7 2014-07~ 00:48:~  393754 3.1.0     x86_64 linux-~ plyr      1.8.1   US          3<br>
 8     8 2014-07~ 00:47:~   28216 3.0.2     x86_64 linux-~ whisker   0.3-2   US          5<br>
 9     9 2014-07~ 00:54:~    5928 NA        NA     NA      Rcpp      0.10.4  CN          6<br>
10    10 2014-07~ 00:15:~ 2206029 3.0.2     x86_64 linux-~ hflights  0.1     US          7<br>
# ... with 225,458 more rows</int></chr></chr></chr></chr></chr></chr></int></chr></chr></int></p>
</blockquote>
<p>| You nailed it! Good job!</p>
<p>|============                                                                    |  15%<br>
| Our first goal is to group the data by package name. Bring up the help file for<br>
| group_by().</p>
<blockquote>
<p>group_by(cran,package)<br>
# A tibble: 225,468 x 11<br>
# Groups:   package [6,023]<br>
       X date     time       size r_version r_arch r_os    package   version country ip_id<br><int><chr><chr><int><chr><chr><chr><chr><chr><chr><int><br>
 1     1 2014-07~ 00:54:~   80589 3.1.0     x86_64 mingw32 htmltools 0.2.4   US          1<br>
 2     2 2014-07~ 00:59:~  321767 3.1.0     x86_64 mingw32 tseries   0.10-32 US          2<br>
 3     3 2014-07~ 00:47:~  748063 3.1.0     x86_64 linux-~ party     1.0-15  US          3<br>
 4     4 2014-07~ 00:48:~  606104 3.1.0     x86_64 linux-~ Hmisc     3.14-4  US          3<br>
 5     5 2014-07~ 00:46:~   79825 3.0.2     x86_64 linux-~ digest    0.6.4   CA          4<br>
 6     6 2014-07~ 00:48:~   77681 3.1.0     x86_64 linux-~ randomFo~ 4.6-7   US          3<br>
 7     7 2014-07~ 00:48:~  393754 3.1.0     x86_64 linux-~ plyr      1.8.1   US          3<br>
 8     8 2014-07~ 00:47:~   28216 3.0.2     x86_64 linux-~ whisker   0.3-2   US          5<br>
 9     9 2014-07~ 00:54:~    5928 NA        NA     NA      Rcpp      0.10.4  CN          6<br>
10    10 2014-07~ 00:15:~ 2206029 3.0.2     x86_64 linux-~ hflights  0.1     US          7<br>
# ... with 225,458 more rows</int></chr></chr></chr></chr></chr></chr></int></chr></chr></int></p>
</blockquote>
<p>| Keep trying! Or, type info() for more options.</p>
<p>| Use ?group_by to bring up the documentation.</p>
<blockquote>
<p>cran %&gt;% group_by(package)<br>
# A tibble: 225,468 x 11<br>
# Groups:   package [6,023]<br>
       X date     time       size r_version r_arch r_os    package   version country ip_id<br><int><chr><chr><int><chr><chr><chr><chr><chr><chr><int><br>
 1     1 2014-07~ 00:54:~   80589 3.1.0     x86_64 mingw32 htmltools 0.2.4   US          1<br>
 2     2 2014-07~ 00:59:~  321767 3.1.0     x86_64 mingw32 tseries   0.10-32 US          2<br>
 3     3 2014-07~ 00:47:~  748063 3.1.0     x86_64 linux-~ party     1.0-15  US          3<br>
 4     4 2014-07~ 00:48:~  606104 3.1.0     x86_64 linux-~ Hmisc     3.14-4  US          3<br>
 5     5 2014-07~ 00:46:~   79825 3.0.2     x86_64 linux-~ digest    0.6.4   CA          4<br>
 6     6 2014-07~ 00:48:~   77681 3.1.0     x86_64 linux-~ randomFo~ 4.6-7   US          3<br>
 7     7 2014-07~ 00:48:~  393754 3.1.0     x86_64 linux-~ plyr      1.8.1   US          3<br>
 8     8 2014-07~ 00:47:~   28216 3.0.2     x86_64 linux-~ whisker   0.3-2   US          5<br>
 9     9 2014-07~ 00:54:~    5928 NA        NA     NA      Rcpp      0.10.4  CN          6<br>
10    10 2014-07~ 00:15:~ 2206029 3.0.2     x86_64 linux-~ hflights  0.1     US          7<br>
# ... with 225,458 more rows</int></chr></chr></chr></chr></chr></chr></int></chr></chr></int></p>
</blockquote>
<p>| You almost had it, but not quite. Try again. Or, type info() for more options.</p>
<p>| Use ?group_by to bring up the documentation.</p>
<blockquote>
<p>?group_by</p>
</blockquote>
<p>| Your dedication is inspiring!</p>
<p>|==============                                                                  |  17%<br>
| Group cran by the package variable and store the result in a new object called<br>
| by_package.</p>
<blockquote>
<p>by_package&lt;-cran %&gt;% group_by(package)</p>
</blockquote>
<p>| That's not the answer I was looking for, but try again. Or, type info() for more<br>
| options.</p>
<p>| Store the result of group_by(cran, package) in a new object called by_package.</p>
<blockquote>
<p>by_package&lt;-group_by(cran,package)</p>
</blockquote>
<p>| You got it right!</p>
<p>|===============                                                                 |  19%<br>
| Let's take a look at by_package. Print it to the console.</p>
<blockquote>
<p>by_package<br>
# A tibble: 225,468 x 11<br>
# Groups:   package [6,023]<br>
       X date     time       size r_version r_arch r_os    package   version country ip_id<br><int><chr><chr><int><chr><chr><chr><chr><chr><chr><int><br>
 1     1 2014-07~ 00:54:~   80589 3.1.0     x86_64 mingw32 htmltools 0.2.4   US          1<br>
 2     2 2014-07~ 00:59:~  321767 3.1.0     x86_64 mingw32 tseries   0.10-32 US          2<br>
 3     3 2014-07~ 00:47:~  748063 3.1.0     x86_64 linux-~ party     1.0-15  US          3<br>
 4     4 2014-07~ 00:48:~  606104 3.1.0     x86_64 linux-~ Hmisc     3.14-4  US          3<br>
 5     5 2014-07~ 00:46:~   79825 3.0.2     x86_64 linux-~ digest    0.6.4   CA          4<br>
 6     6 2014-07~ 00:48:~   77681 3.1.0     x86_64 linux-~ randomFo~ 4.6-7   US          3<br>
 7     7 2014-07~ 00:48:~  393754 3.1.0     x86_64 linux-~ plyr      1.8.1   US          3<br>
 8     8 2014-07~ 00:47:~   28216 3.0.2     x86_64 linux-~ whisker   0.3-2   US          5<br>
 9     9 2014-07~ 00:54:~    5928 NA        NA     NA      Rcpp      0.10.4  CN          6<br>
10    10 2014-07~ 00:15:~ 2206029 3.0.2     x86_64 linux-~ hflights  0.1     US          7<br>
# ... with 225,458 more rows</int></chr></chr></chr></chr></chr></chr></int></chr></chr></int></p>
</blockquote>
<p>| Excellent work!</p>
<p>|=================                                                               |  21%<br>
| At the top of the output above, you'll see 'Groups: package', which tells us that this<br>
| tbl has been grouped by the package variable. Everything else looks the same, but now<br>
| any operation we apply to the grouped data will take place on a per package basis.</p>
<p>...</p>
<p>|==================                                                              |  23%<br>
| Recall that when we applied mean(size) to the original tbl_df via summarize(), it<br>
| returned a single number -- the mean of all values in the size column. We may care<br>
| about what that number is, but wouldn't it be so much more interesting to look at the<br>
| mean download size for each unique package?</p>
<p>...</p>
<p>|====================                                                            |  25%<br>
| That's exactly what you'll get if you use summarize() to apply mean(size) to the<br>
| grouped data in by_package. Give it a shot.</p>
<blockquote>
<p>summarise(by_package,mean(size))<br>
# A tibble: 6,023 x 2<br>
   package     <code>mean(size)</code><br><chr><dbl><br>
 1 A3                62195.<br>
 2 abc             4826665<br>
 3 abcdeFBA         455980.<br>
 4 ABCExtremes       22904.<br>
 5 ABCoptim          17807.<br>
 6 ABCp2             30473.<br>
 7 abctools        2589394<br>
 8 abd              453631.<br>
 9 abf2              35693.<br>
10 abind             32939.<br>
# ... with 6,013 more rows</dbl></chr></p>
</blockquote>
<p>| You got it right!</p>
<p>|======================                                                          |  27%<br>
| Instead of returning a single value, summarize() now returns the mean size for EACH<br>
| package in our dataset.</p>
<p>...</p>
<p>|=======================                                                         |  29%<br>
| Let's take it a step further. I just opened an R script for you that contains a<br>
| partially constructed call to summarize(). Follow the instructions in the script<br>
| comments.<br>
|<br>
| When you are ready to move on, save the script and type submit(), or type reset() to<br>
| reset the script to its original state.</p>
<blockquote>
<p>play()</p>
</blockquote>
<p>| Entering play mode. Experiment as you please, then type nxt() when you are ready to<br>
| resume the lesson.</p>
<blockquote>
<p>?n<br>
?n_distinct<br>
nxt()</p>
</blockquote>
<p>| Resuming lesson...</p>
<p>| Let's take it a step further. I just opened an R script for you that contains a<br>
| partially constructed call to summarize(). Follow the instructions in the script<br>
| comments.<br>
|<br>
| When you are ready to move on, save the script and type submit(), or type reset() to<br>
| reset the script to its original state.</p>

<pre><code>{r}
# Compute four values, in the following order, from
# the grouped data:
#
# 1. count = n()
# 2. unique = n_distinct(ip_id)
# 3. countries = n_distinct(country)
# 4. avg_bytes = mean(size)
#
# A few thing to be careful of:
#
# 1. Separate arguments by commas
# 2. Make sure you have a closing parenthesis
# 3. Check your spelling!
# 4. Store the result in pack_sum (for 'package summary')
#
# You should also take a look at ?n and ?n_distinct, so
# that you really understand what is going on.

pack_sum &lt;- summarize(by_package,
                      count = n(),
                      unique = n_distinct(ip_id),
                      countries = n_distinct(country),
                      avg_bytes = mean(size))</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p>| You are doing so well!</p>
<p>|=========================                                                       |  31%<br>
| Print the resulting tbl, pack_sum, to the console to examine its contents.</p>
<blockquote>
<p>pack_sum<br>
# A tibble: 6,023 x 5<br>
   package     count unique countries avg_bytes<br><chr><int><int><int><dbl><br>
 1 A3             25     24        10    62195.<br>
 2 abc            29     25        16  4826665<br>
 3 abcdeFBA       15     15         9   455980.<br>
 4 ABCExtremes    18     17         9    22904.<br>
 5 ABCoptim       16     15         9    17807.<br>
 6 ABCp2          18     17        10    30473.<br>
 7 abctools       19     19        11  2589394<br>
 8 abd            17     16        10   453631.<br>
 9 abf2           13     13         9    35693.<br>
10 abind         396    365        50    32939.<br>
# ... with 6,013 more rows</dbl></int></int></int></chr></p>
</blockquote>
<p>| That's the answer I was looking for.</p>
<p>|==========================                                                      |  33%<br>
| The 'count' column, created with n(), contains the total number of rows (i.e.<br>
| downloads) for each package. The 'unique' column, created with n_distinct(ip_id), gives<br>
| the total number of unique downloads for each package, as measured by the number of<br>
| distinct ip_id's. The 'countries' column, created with n_distinct(country), provides<br>
| the number of countries in which each package was downloaded. And finally, the<br>
| 'avg_bytes' column, created with mean(size), contains the mean download size (in bytes)<br>
| for each package.</p>
<p>...</p>
<p>|============================                                                    |  35%<br>
| It's important that you understand how each column of pack_sum was created and what it<br>
| means. Now that we've summarized the data by individual packages, let's play around<br>
| with it some more to see what we can learn.</p>
<p>...</p>
<p>|=============================                                                   |  37%<br>
| Naturally, we'd like to know which packages were most popular on the day these data<br>
| were collected (July 8, 2014). Let's start by isolating the top 1% of packages, based<br>
| on the total number of downloads as measured by the 'count' column.</p>
<p>...</p>
<p>|===============================                                                 |  38%<br>
| We need to know the value of 'count' that splits the data into the top 1% and bottom<br>
| 99% of packages based on total downloads. In statistics, this is called the 0.99, or<br>
| 99%, sample quantile. Use quantile(pack_sum$count, probs = 0.99) to determine this<br>
| number.</p>
<blockquote>
<p>quantile(pack_sum$count, probs = 0.99)<br>
   99%<br>
679.56</p>
</blockquote>
<p>| You're the best!</p>
<p>|================================                                                |  40%<br>
| Now we can isolate only those packages which had more than 679 total downloads. Use<br>
| filter() to select all rows from pack_sum for which 'count' is strictly greater (&gt;)<br>
| than 679. Store the result in a new object called top_counts.</p>
<blockquote>
<p>top_counts&lt;-filter(pack_sum,count&gt;679)</p>
</blockquote>
<p>| You are doing so well!</p>
<p>|==================================                                              |  42%<br>
| Let's take a look at top_counts. Print it to the console.</p>
<blockquote>
<p>top_counts<br>
# A tibble: 61 x 5<br>
   package    count unique countries avg_bytes<br><chr><int><int><int><dbl><br>
 1 bitops      1549   1408        76    28715.<br>
 2 car         1008    837        64  1229122.<br>
 3 caTools      812    699        64   176589.<br>
 4 colorspace  1683   1433        80   357411.<br>
 5 data.table   680    564        59  1252721.<br>
 6 DBI         2599    492        48   206933.<br>
 7 devtools     769    560        55   212933.<br>
 8 dichromat   1486   1257        74   134732.<br>
 9 digest      2210   1894        83   120549.<br>
10 doSNOW       740     75        24     8364.<br>
# ... with 51 more rows</dbl></int></int></int></chr></p>
</blockquote>
<p>| You are amazing!</p>
<p>|===================================                                             |  44%<br>
| There are only 61 packages in our top 1%, so we'd like to see all of them. Since dplyr<br>
| only shows us the first 10 rows, we can use the View() function to see more.</p>
<p>...</p>
<p>|=====================================                                           |  46%<br>
| View all 61 rows with View(top_counts). Note that the 'V' in View() is capitalized.</p>
<blockquote>
<p>View(top_counts)</p>
</blockquote>
<p><img src="../../images/r0040180.png" alt="top_counts" title="top_counts"></p>
<p>| You're the best!</p>
<p>|======================================                                          |  48%<br>
| arrange() the rows of top_counts based on the 'count' column and assign the result to a<br>
| new object called top_counts_sorted. We want the packages with the highest number of<br>
| downloads at the top, which means we want 'count' to be in descending order. If you<br>
| need help, check out ?arrange and/or ?desc.</p>
<blockquote>
<p>top_counts_sorted&lt;-arrange(top_counts,count)</p>
</blockquote>
<p>| Almost! Try again. Or, type info() for more options.</p>
<p>| arrange(top_counts, desc(count)) will arrange the rows of top_counts based on the<br>
| values of the 'count' variable, in descending order. Don't forget to assign the result<br>
| to top_counts_sorted.</p>
<blockquote>
<p>top_counts_sorted&lt;-arrange(top_counts,desc(count))</p>
</blockquote>
<p>| All that hard work is paying off!</p>
<p>|========================================                                        |  50%<br>
| Now use View() again to see all 61 rows of top_counts_sorted.</p>
<blockquote>
<p>View(top_counts_sorted)</p>
</blockquote>
<p><img src="../../images/r0040190.png" alt="top_counts_sorted" title="top_counts_sorted"></p>
<p>| You are amazing!</p>
<p>|==========================================                                      |  52%<br>
| If we use total number of downloads as our metric for popularity, then the above output<br>
| shows us the most popular packages downloaded from the RStudio CRAN mirror on July 8,<br>
| 2014. Not surprisingly, ggplot2 leads the pack with 4602 downloads, followed by Rcpp,<br>
| plyr, rJava, ....</p>
<p>...</p>
<p>|===========================================                                     |  54%<br>
| ...And if you keep on going, you'll see swirl at number 43, with 820 total downloads.<br>
| Sweet!</p>
<p>...</p>
<p>|=============================================                                   |  56%<br>
| Perhaps we're more interested in the number of <em>unique</em> downloads on this particular<br>
| day. In other words, if a package is downloaded ten times in one day from the same<br>
| computer, we may wish to count that as only one download. That's what the 'unique'<br>
| column will tell us.</p>
<p>...</p>
<p>|==============================================                                  |  58%<br>
| Like we did with 'count', let's find the 0.99, or 99%, quantile for the 'unique'<br>
| variable with quantile(pack_sum$unique, probs = 0.99).</p>
<blockquote>
<p>quantile(pack_sum$unique,probs = 0.99)<br>
99%<br>
465</p>
</blockquote>
<p>| Nice work!</p>
<p>|================================================                                |  60%<br>
| Apply filter() to pack_sum to select all rows corresponding to values of 'unique' that<br>
| are strictly greater than 465. Assign the result to a object called top_unique.</p>
<blockquote>
<p>top_unique&lt;-filter(pack_sum,unique&gt;465)</p>
</blockquote>
<p>| Keep up the great work!</p>
<p>|=================================================                               |  62%<br>
| Let's View() our top contenders!</p>
<blockquote>
<p>View(top_unique)</p>
</blockquote>
<p><img src="../../images/r0040200.png" alt="top_unique" title="top_unique"></p>
<p>| That's a job well done!</p>
<p>|===================================================                             |  63%<br>
| Now arrange() top_unique by the 'unique' column, in descending order, to see which<br>
| packages were downloaded from the greatest number of unique IP addresses. Assign the<br>
| result to top_unique_sorted.</p>
<blockquote>
<p>top_unique_sorted&lt;-arrange(top_unique,desc(unique))</p>
</blockquote>
<p>| You are really on a roll!</p>
<p>|====================================================                            |  65%<br>
| View() the sorted data.</p>
<blockquote>
<p>View(top_unique_sorted)</p>
</blockquote>
<p><img src="../../images/r0040210.png" alt="top_unique_sorted" title="top_unique_sorted"></p>
<p>| All that practice is paying off!</p>
<p>|======================================================                          |  67%<br>
| Now Rcpp is in the lead, followed by stringr, digest, plyr, and ggplot2. swirl moved up<br>
| a few spaces to number 40, with 698 unique downloads. Nice!</p>
<p>...</p>
<p>|=======================================================                         |  69%<br>
| Our final metric of popularity is the number of distinct countries from which each<br>
| package was downloaded. We'll approach this one a little differently to introduce you<br>
| to a method called 'chaining' (or 'piping').</p>
<p>...</p>
<p>|=========================================================                       |  71%<br>
| Chaining allows you to string together multiple function calls in a way that is compact<br>
| and readable, while still accomplishing the desired result. To make it more concrete,<br>
| let's compute our last popularity metric from scratch, starting with our original data.</p>
<p>...</p>
<p>|==========================================================                      |  73%<br>
| I've opened up a script that contains code similar to what you've seen so far. Don't<br>
| change anything. Just study it for a minute, make sure you understand everything that's<br>
| there, then submit() when you are ready to move on.</p>

<pre><code>{r}
# Don't change any of the code below. Just type submit()
# when you think you understand it.

# We've already done this part, but we're repeating it
# here for clarity.

by_package &lt;- group_by(cran, package)
pack_sum &lt;- summarize(by_package,
                      count = n(),
                      unique = n_distinct(ip_id),
                      countries = n_distinct(country),
                      avg_bytes = mean(size))

# Here's the new bit, but using the same approach we've
# been using this whole time.

top_countries &lt;- filter(pack_sum, countries &gt; 60)
result1 &lt;- arrange(top_countries, desc(countries), avg_bytes)

# Print the results to the console.
print(result1)</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 46 x 5<br>
   package      count unique countries avg_bytes<br><chr><int><int><int><dbl><br>
 1 Rcpp          3195   2044        84  2512100.<br>
 2 digest        2210   1894        83   120549.<br>
 3 stringr       2267   1948        82    65277.<br>
 4 plyr          2908   1754        81   799123.<br>
 5 ggplot2       4602   1680        81  2427716.<br>
 6 colorspace    1683   1433        80   357411.<br>
 7 RColorBrewer  1890   1584        79    22764.<br>
 8 scales        1726   1408        77   126819.<br>
 9 bitops        1549   1408        76    28715.<br>
10 reshape2      2032   1652        76   330128.<br>
# ... with 36 more rows</dbl></int></int></int></chr></p>
<p>| That's a job well done!</p>
<p>|============================================================                    |  75%<br>
| It's worth noting that we sorted primarily by country, but used avg_bytes (in ascending<br>
| order) as a tie breaker. This means that if two packages were downloaded from the same<br>
| number of countries, the package with a smaller average download size received a higher<br>
| ranking.</p>
<p>...</p>
<p>|==============================================================                  |  77%<br>
| We'd like to accomplish the same result as the last script, but avoid saving our<br>
| intermediate results. This requires embedding function calls within one another.</p>
<p>...</p>
<p>|===============================================================                 |  79%<br>
| That's exactly what we've done in this script. The result is equivalent, but the code<br>
| is much less readable and some of the arguments are far away from the function to which<br>
| they belong. Again, just try to understand what is going on here, then submit() when<br>
| you are ready to see a better solution.</p>

<pre><code>{r}
# Don't change any of the code below. Just type submit()
# when you think you understand it. If you find it
# confusing, you're absolutely right!

result2 &lt;-
  arrange(
    filter(
      summarize(
        group_by(cran,
                 package
        ),
        count = n(),
        unique = n_distinct(ip_id),
        countries = n_distinct(country),
        avg_bytes = mean(size)
      ),
      countries &gt; 60
    ),
    desc(countries),
    avg_bytes
  )

print(result2)</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 46 x 5<br>
   package      count unique countries avg_bytes<br><chr><int><int><int><dbl><br>
 1 Rcpp          3195   2044        84  2512100.<br>
 2 digest        2210   1894        83   120549.<br>
 3 stringr       2267   1948        82    65277.<br>
 4 plyr          2908   1754        81   799123.<br>
 5 ggplot2       4602   1680        81  2427716.<br>
 6 colorspace    1683   1433        80   357411.<br>
 7 RColorBrewer  1890   1584        79    22764.<br>
 8 scales        1726   1408        77   126819.<br>
 9 bitops        1549   1408        76    28715.<br>
10 reshape2      2032   1652        76   330128.<br>
# ... with 36 more rows</dbl></int></int></int></chr></p>
<p>| That's a job well done!</p>
<p>|=================================================================               |  81%<br>
| In this script, we've used a special chaining operator, %&gt;%, which was originally<br>
| introduced in the magrittr R package and has now become a key component of dplyr. You<br>
| can pull up the related documentation with ?chain. The benefit of %&gt;% is that it allows<br>
| us to chain the function calls in a linear fashion. The code to the right of %&gt;%<br>
| operates on the result from the code to the left of %&gt;%.<br>
|<br>
| Once again, just try to understand the code, then type submit() to continue.</p>

<pre><code>{r}
# Read the code below, but don't change anything. As
# you read it, you can pronounce the %&gt;% operator as
# the word 'then'.
#
# Type submit() when you think you understand
# everything here.

result3 &lt;-
  cran %&gt;%
  group_by(package) %&gt;%
  summarize(count = n(),
            unique = n_distinct(ip_id),
            countries = n_distinct(country),
            avg_bytes = mean(size)
  ) %&gt;%
  filter(countries &gt; 60) %&gt;%
  arrange(desc(countries), avg_bytes)

# Print result to console
print(result3)</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 46 x 5<br>
   package      count unique countries avg_bytes<br><chr><int><int><int><dbl><br>
 1 Rcpp          3195   2044        84  2512100.<br>
 2 digest        2210   1894        83   120549.<br>
 3 stringr       2267   1948        82    65277.<br>
 4 plyr          2908   1754        81   799123.<br>
 5 ggplot2       4602   1680        81  2427716.<br>
 6 colorspace    1683   1433        80   357411.<br>
 7 RColorBrewer  1890   1584        79    22764.<br>
 8 scales        1726   1408        77   126819.<br>
 9 bitops        1549   1408        76    28715.<br>
10 reshape2      2032   1652        76   330128.<br>
# ... with 36 more rows</dbl></int></int></int></chr></p>
<p>| You nailed it! Good job!</p>
<p>|==================================================================              |  83%<br>
| So, the results of the last three scripts are all identical. But, the third script<br>
| provides a convenient and concise alternative to the more traditional method that we've<br>
| taken previously, which involves saving results as we go along.</p>
<p>...</p>
<p>|====================================================================            |  85%<br>
| Once again, let's View() the full data, which has been stored in result3.</p>
<blockquote>
<p>View(result3)</p>
</blockquote>
<p><img src="../../images/r0040220.png" alt="result3" title="result3"></p>
<p>| That's correct!</p>
<p>|=====================================================================           |  87%<br>
| It looks like Rcpp is on top with downloads from 84 different countries, followed by<br>
| digest, stringr, plyr, and ggplot2. swirl jumped up the rankings again, this time to<br>
| 27th.</p>
<p>...</p>
<p>|=======================================================================         |  88%<br>
| To help drive the point home, let's work through a few more examples of chaining.</p>
<p>...</p>
<p>|========================================================================        |  90%<br>
| Let's build a chain of dplyr commands one step at a time, starting with the script I<br>
| just opened for you.</p>

<pre><code>{r}
# select() the following columns from cran. Keep in mind
# that when you're using the chaining operator, you don't
# need to specify the name of the data tbl in your call to
# select().
#
# 1. ip_id
# 2. country
# 3. package
# 4. size
#
# The call to print() at the end of the chain is optional,
# but necessary if you want your results printed to the
# console. Note that since there are no additional arguments
# to print(), you can leave off the parentheses after
# the function name. This is a convenient feature of the %&gt;%
# operator.

cran %&gt;%
  select(ip_id,country,package,size) %&gt;%
    print</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 225,468 x 4<br>
   ip_id country package         size<br><int><chr><chr><int><br>
 1     1 US      htmltools      80589<br>
 2     2 US      tseries       321767<br>
 3     3 US      party         748063<br>
 4     3 US      Hmisc         606104<br>
 5     4 CA      digest         79825<br>
 6     3 US      randomForest   77681<br>
 7     3 US      plyr          393754<br>
 8     5 US      whisker        28216<br>
 9     6 CN      Rcpp            5928<br>
10     7 US      hflights     2206029<br>
# ... with 225,458 more rows</int></chr></chr></int></p>
<p>| All that hard work is paying off!</p>
<p>|==========================================================================      |  92%<br>
| Let's add to the chain.</p>

<pre><code>{r}
# Use mutate() to add a column called size_mb that contains
# the size of each download in megabytes (i.e. size / 2^20).
#
# If you want your results printed to the console, add
# print to the end of your chain.

cran %&gt;%
  select(ip_id, country, package, size) %&gt;%
  mutate(size_mb=size/2^20) %&gt;%
  print</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 225,468 x 5<br>
   ip_id country package         size size_mb<br><int><chr><chr><int><dbl><br>
 1     1 US      htmltools      80589 0.0769<br>
 2     2 US      tseries       321767 0.307<br>
 3     3 US      party         748063 0.713<br>
 4     3 US      Hmisc         606104 0.578<br>
 5     4 CA      digest         79825 0.0761<br>
 6     3 US      randomForest   77681 0.0741<br>
 7     3 US      plyr          393754 0.376<br>
 8     5 US      whisker        28216 0.0269<br>
 9     6 CN      Rcpp            5928 0.00565<br>
10     7 US      hflights     2206029 2.10<br>
# ... with 225,458 more rows</dbl></int></chr></chr></int></p>
<p>| All that practice is paying off!</p>
<p>|===========================================================================     |  94%<br>
| A little bit more now.</p>

<pre><code>{r}
# Use filter() to select all rows for which size_mb is
# less than or equal to (&lt;=) 0.5.
#
# If you want your results printed to the console, add
# print to the end of your chain.

cran %&gt;%
  select(ip_id, country, package, size) %&gt;%
  mutate(size_mb = size / 2^20) %&gt;%
  # Your call to filter() goes here
  filter(size_mb&lt;=0.5) %&gt;%
  print</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 142,021 x 5<br>
   ip_id country package        size size_mb<br><int><chr><chr><int><dbl><br>
 1     1 US      htmltools     80589 0.0769<br>
 2     2 US      tseries      321767 0.307<br>
 3     4 CA      digest        79825 0.0761<br>
 4     3 US      randomForest  77681 0.0741<br>
 5     3 US      plyr         393754 0.376<br>
 6     5 US      whisker       28216 0.0269<br>
 7     6 CN      Rcpp           5928 0.00565<br>
 8    13 DE      ipred        186685 0.178<br>
 9    14 US      mnormt        36204 0.0345<br>
10    16 US      iterators    289972 0.277<br>
# ... with 142,011 more rows</dbl></int></chr></chr></int></p>
<p>| You got it!</p>
<p>|=============================================================================   |  96%<br>
| And finish it off.</p>

<pre><code>{r}
# arrange() the result by size_mb, in descending order.
#
# If you want your results printed to the console, add
# print to the end of your chain.

cran %&gt;%
  select(ip_id, country, package, size) %&gt;%
  mutate(size_mb = size / 2^20) %&gt;%
  filter(size_mb &lt;= 0.5) %&gt;%
  # Your call to arrange() goes here
  arrange(desc(size_mb)) %&gt;%
  print</code></pre>
<blockquote>
<p>submit()</p>
</blockquote>
<p>| Sourcing your script...</p>
<p># A tibble: 142,021 x 5<br>
   ip_id country package                 size size_mb<br><int><chr><chr><int><dbl><br>
 1 11034 DE      phia                  524232   0.500<br>
 2  9643 US      tis                   524152   0.500<br>
 3  1542 IN      RcppSMC               524060   0.500<br>
 4 12354 US      lessR                 523916   0.500<br>
 5 12072 US      colorspace            523880   0.500<br>
 6  2514 KR      depmixS4              523863   0.500<br>
 7  1111 US      depmixS4              523858   0.500<br>
 8  8865 CR      depmixS4              523858   0.500<br>
 9  5908 CN      RcmdrPlugin.KMggplot2 523852   0.500<br>
10 12354 US      RcmdrPlugin.KMggplot2 523852   0.500<br>
# ... with 142,011 more rows</dbl></int></chr></chr></int></p>
<p>| You got it!</p>
<p>|==============================================================================  |  98%<br>
| In this lesson, you learned about grouping and chaining using dplyr. You combined some<br>
| of the things you learned in the previous lesson with these more advanced ideas to<br>
| produce concise, readable, and highly effective code. Welcome to the wonderful world of<br>
| dplyr!</p>
<p>...</p>
<p>|================================================================================| 100%<br>
| Would you like to receive credit for completing this course on Coursera.org?</p>
<p>1: Yes<br>
2: No</p>
<p>Selection: 1<br>
What is your email address? xxxxxx@xxxxxxxxxxxx<br>
What is your assignment token? xXxXxxXXxXxxXXXx<br>
Grade submission succeeded!</p>
<p>| Perseverance, that's the answer.</p>
<p>| You've reached the end of this lesson! Returning to the main menu...</p>
<p>| Please choose a course, or type 0 to exit swirl.</p>
<p>1: Getting and Cleaning Data<br>
2: R Programming<br>
3: Take me to the swirl course repository!</p>
<p>Selection: 0</p>
<p>| Leaving swirl now. Type swirl() to resume.</p>
<blockquote>
<p>ls()<br>
 [1] "by_package"        "cran"              "pack_sum"          "result1"<br>
 [5] "result2"           "result3"           "top_countries"     "top_counts"<br>
 [9] "top_counts_sorted" "top_unique"        "top_unique_sorted"<br>
rm(list=ls())</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last updated 2020-04-23 21:01:55.271179 IST</em></p>

</div>
</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../tags/chaining/" rel="tag">chaining</a></li>
            <li><a class="tag p-category" href="../../tags/dplyr/" rel="tag">dplyr</a></li>
            <li><a class="tag p-category" href="../../tags/group_by/" rel="tag">group_by</a></li>
            <li><a class="tag p-category" href="../../tags/piping/" rel="tag">piping</a></li>
            <li><a class="tag p-category" href="../../tags/quantile/" rel="tag">quantile</a></li>
            <li><a class="tag p-category" href="../../tags/r/" rel="tag">R</a></li>
            <li><a class="tag p-category" href="../../tags/swirl/" rel="tag">swirl</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../00416/" rel="prev" title="Manipulating Data with dplyr">Previous post</a>
            </li>
            <li class="next">
                <a href="../00418/" rel="next" title="Tidying Data with tidyr">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
        
<script>
var idcomments_acct = '7fae5836cfdd49cac599cac5b95695d1';
var idcomments_post_id = "cache/posts/00417_Grouping and Chaining with dplyr.html";
var idcomments_post_url = "https://www.datascience.eu.org/posts/00417/";
</script><span id="IDCommentsPostTitle" style="display:none"></span>
<script src="https://www.intensedebate.com/js/genericCommentWrapperV2.js"></script></section><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script></article><!--End of body content--><footer id="footer">
            Contents © 2020 Krishnakanth Allika 
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-163231811-1"></script><script>  window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-163231811-1'); gtag('set', {'user_id': 'USER_ID'});</script>
</body>
</html>
